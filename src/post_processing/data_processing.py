import csv
import numpy as np 
import matplotlib.pyplot as plt
import math
import argparse
from scipy.spatial.transform import Rotation
from scipy import signal
from scipy.signal import savgol_filter

import sys, os
sys.path.append('./')
from config import *
from post_processing.data_preview import DataPreviewClass

class DataProcessClass():

    def __init__(self, 
        name_of_data_csv=None,
        robot_env = '', # pybullet / solo
        point_on_platform = [0,0,0],
        raw_data_traj_platform = GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_PLATFORM_FILE_NAME,
        external_output_directory = "", # specify if you do not want to use config output directory
        external_output_file_name = "", # specify if you do not want to use config output directory
        save_data = True,
        save_history = True,
        update_data = False
    ):
        self.name_of_data_csv = name_of_data_csv 
        self.robot_env = robot_env
        self.point_on_platform = point_on_platform
        self.external_output_directory = external_output_directory
        self.external_output_file_name = external_output_file_name
        self.save_data = save_data
        self.save_history = save_history
        self.update_data = update_data

        if self.robot_env == '':
            print("Robot env not specified. Exiting!")
            exit(-1)
        
        self.init_fr_leg_params()

        print('Loading data...', end='\r')
        self.seq_num = []
        self.time_stamp = [] 
        self.curr_jointAngles = [] 
        self.target_jointAngles = []
        self.current_value = []
        self.platform_target = self.get_raw_data_from_csv(raw_data_traj_platform)
        self.platform_target = np.array(self.platform_target)
        if self.update_data:
            self.platform_target = self.platform_target[:,19:37]
        
        try:
            self.fill_values_from_csv()
        except:
            print("Unable to fill values from csv. Is csv empty? ==>", self.name_of_data_csv)
            exit(-1)

        print('Loading data...done')
        if self.robot_env == 'pybullet': 
            self.frequency = 240
            self.curr_jointAngles = self.map_motors_according_to_ctrl_robot(self.curr_jointAngles)
            self.target_jointAngles = self.map_motors_according_to_ctrl_robot(self.target_jointAngles)
            self.current_value = self.map_motors_according_to_ctrl_robot(self.current_value)
        elif self.robot_env == 'solo':
            self.frequency = 1000

        self.get_calculated_platform_vel_acc()

        if self.robot_env == 'solo':
            self.imu_data_transformation()

        self.save_calculated_platform_vel_acc()

      
    def init_fr_leg_params(self):
        """
            Initializes motor mapping and parameters for fr joint leg. 

            :return: None.
            :rtype: None.
        """
        self.iq_sat = 12
        self.imu_data = []
        self.motor_mapping = {
            "bl_hip" : 0,
            "br_hip" : 1,
            "bl_lower" : 2,
            "bl_upper" : 3,
            "br_lower" : 4,
            "br_upper" : 5,
            "fl_hip" : 6,
            "fr_hip" : 7,
            "fl_lower" : 8,
            "fl_upper" : 9,
            "fr_lower" : 10,
            "fr_upper" : 11,
            0 : "bl_hip",
            1 : "br_hip",
            2 : "bl_lower",
            3 : "bl_upper",
            4 : "br_lower",
            5 : "br_upper",
            6 : "fl_hip",
            7 : "fr_hip",
            8 : "fl_lower",
            9 : "fl_upper",
            10 : "fr_lower",
            11 : "fr_upper" 
        }
    

    def map_motors_according_to_ctrl_robot(self, values):
        """
            Maps PyBullet motor indices to solo robot motor indices. 

            :param values: Motor values with motor index following PyBullet motor index convention.
            :type values: ndarray.
            :return: Updated motor values with motor index following SOLO robot motor index convention.
            :rtype: ndarray.
        """
        values = np.array(values)

        if len(values.T) != 12 and len(values.T) != 16:
            print("Number of joint positions != 12 or 16. Exiting!")
            exit(-1) 

        if len(values.T) == 16: # removing dummy joints if input
            dummy_joints = [3,7,11,15]
            updated_values = []
            for v in values:
                temp = []
                for ti, tv in enumerate(v):
                    if ti in dummy_joints:
                        continue
                    else:
                        temp.append(tv)
                updated_values.append(temp)
        
            values = updated_values
        
        mapped_values = []
        for value in values:
            mapped_value = [None] * 12
            mapped_value[self.motor_mapping["bl_hip"]] = - value[6] # bl_hip = hip_left_back 
            mapped_value[self.motor_mapping["br_hip"]] = value[9] # br_hip = hip_right_back
            mapped_value[self.motor_mapping["bl_lower"]] = value[8] # bl_lower = lower_leg_left_back
            mapped_value[self.motor_mapping["bl_upper"]] = value[7] # bl_upper = upper_leg_left_back
            mapped_value[self.motor_mapping["br_lower"]] = value[11] # br_lower = lower_leg_right_back
            mapped_value[self.motor_mapping["br_upper"]] = value[10] # br_upper = upper_leg_right_back
            mapped_value[self.motor_mapping["fl_hip"]] = value[0] # fl_hip = hip_left_front
            mapped_value[self.motor_mapping["fr_hip"]] = - value[3] # fr_hip = hip_right_front
            mapped_value[self.motor_mapping["fl_lower"]] = value[2] # fl_lower = lower_leg_left_front
            mapped_value[self.motor_mapping["fl_upper"]] = value[1] # fl_upper = upper_leg_left_front
            mapped_value[self.motor_mapping["fr_lower"]] = value[5] # fr_lower = lower_leg_right_front
            mapped_value[self.motor_mapping["fr_upper"]] = value[4] # fr_upper = upper_leg_right_front
            mapped_values.append(mapped_value)
        return np.array(mapped_values)

    
    def fill_values_from_csv(self):
        """
            Fills values from csv file. 

            :return: None.
            :rtype: None.
        """
        raw_data = np.array(self.get_raw_data_from_csv(self.name_of_data_csv, header=True))

        if self.name_of_data_csv == GLOBAL_OUTPUT_DIRECTORY + PYBULLET_DATA_OUTPUT_FILE_NAME:
            self.seq_num = raw_data[:, 0]
            self.time_stamp = self.seq_num
            self.curr_jointAngles = raw_data[:, 1 : 17]
            self.target_jointAngles = raw_data[:, 17 : 33]     
            self.current_value = raw_data[:, 33 : 49]   
  
        else:
            self.time_stamp = raw_data[:-TIME_INTERPOLATE_LANDING+1, 0]
            self.time_stamp = self.time_stamp - self.time_stamp[0] # correct timestamp
            self.curr_jointAngles = raw_data[:-TIME_INTERPOLATE_LANDING+1, 1 : 13]
            self.target_jointAngles = raw_data[:-TIME_INTERPOLATE_LANDING+1, 13 : 25]
            self.current_value = raw_data[:-TIME_INTERPOLATE_LANDING+1, 25 : 37]
            self.imu_data = raw_data[:-TIME_INTERPOLATE_LANDING+1, 37 : 49]
         

    def get_raw_data_from_csv(self, name_of_csv_file, header=True):
        """
            Returns raw data from any csv file. 

            :param name_of_data_csv_file: Name of csv file.
            :type name_of_data_csv_file: str.
            :param header: Specify whether csv file have header or not.
            :type header: Bool.
            :return: Returns list of rows from csv file.
            :rtype: List[List[Float]].
        """
        f = open(name_of_csv_file)
        csv_reader = csv.reader(f)
        data = [] 
        header_skipped = False 
        for line in csv_reader:
            temp = []
            if not header_skipped and header:
                header_skipped = True 
                continue 
            for e in line:
                try:
                    temp.append(float(e))
                except:
                    temp.append(e)
            data.append(temp)
        return data 


    def get_calculated_platform_vel_acc(self):
        """
            Gets calculated position, velocity, and acceleration for platform using forward kinematics. 

            :return: None.
            :rtype: None.
        """
        self.init_params_for_calculations()
        self.calculate_platform_vel_acc()

    
    def save_calculated_platform_vel_acc(self):
        """
            Saves calculated platform position, velocity, and acceleration.

            :return: None.
            :rtype: None.
        """
        if self.robot_env == 'solo':
            self.save_output_file_name = GLOBAL_OUTPUT_DIRECTORY + SOLO_CALCULATED_FILE_NAME
            if self.external_output_directory == "":
                self.save_output_file_name_c = GLOBAL_OUTPUT_DIRECTORY + HISTORY_DIR + SOLO_CALCULATED_FILE_UNIQUE
            else:
                self.save_output_file_name_c = self.external_output_directory + self.external_output_file_name
        elif self.robot_env == 'pybullet':
            self.save_output_file_name = GLOBAL_OUTPUT_DIRECTORY + PYBULLET_CALCULATED_FILE_NAME
            if self.external_output_directory == "":
                self.save_output_file_name_c = GLOBAL_OUTPUT_DIRECTORY + HISTORY_DIR + PYBULLET_CALCULATED_FILE_UNIQUE
            else:
                self.save_output_file_name_c = self.external_output_directory + self.external_output_file_name
        if self.save_data:
            self.save_f = open(self.save_output_file_name, 'w')
        if self.save_history:
            self.save_f_c = open(self.save_output_file_name_c, 'w')

        if self.robot_env == 'solo':
            header = ['t', 
                        'lx', 'ly', 'lz', 
                        'ax', 'ay', 'az', 
                        'lvx', 'lvy', 'lvz', 
                        'avx', 'avy', 'avz', 
                        'lax', 'lay', 'laz',
                        'aax', 'aay', 'aaz',
                        'target_lx', 'target_ly', 'target_lz', 
                        'target_ax', 'target_ay', 'target_az',
                        'target_lvx', 'target_lvy', 'target_lvz', 
                        'target_avx', 'target_avy', 'target_avz', 
                        'target_lax', 'target_lay', 'target_laz',
                        'target_aax', 'target_aay', 'target_aaz',
                        'transformed_lax', 'transformed_lay', 'transformed_laz',
                        'transformed_aax', 'transformed_aay', 'transformed_aaz'
                    ] 
        elif self.robot_env == 'pybullet': # no transformed IMU data
            header = ['t', 
                        'lx', 'ly', 'lz', 
                        'ax', 'ay', 'az', 
                        'lvx', 'lvy', 'lvz', 
                        'avx', 'avy', 'avz', 
                        'lax', 'lay', 'laz',
                        'aax', 'aay', 'aaz',
                        'target_lx', 'target_ly', 'target_lz', 
                        'target_ax', 'target_ay', 'target_az',
                        'target_lvx', 'target_lvy', 'target_lvz', 
                        'target_avx', 'target_avy', 'target_avz', 
                        'target_lax', 'target_lay', 'target_laz',
                        'target_aax', 'target_aay', 'target_aaz',
                    ] 

        if self.save_data:
            self.data_writer = csv.writer(self.save_f)
            self.data_writer.writerow(header)
        if self.save_history:
            self.data_writer_c = csv.writer(self.save_f_c)
            self.data_writer_c.writerow(header)

        if self.save_data or self.save_history:
            for i in range(len(self.time_stamp)):
                tr = [] 
                tr.append(self.time_stamp[i])
                for j in range(3):
                    tr.append(self.platform_pos_calc[i][j])
                for j in range(3):
                    tr.append(self.platform_ang_calc[i][j])
                for j in range(3):
                    tr.append(self.platform_lin_vel_calc[i][j])
                for j in range(3):
                    tr.append(self.platform_ang_vel_calc[i][j])
                for j in range(3):
                    tr.append(self.platform_lin_acc_calc[i][j])
                for j in range(3):
                    tr.append(self.platform_ang_acc_calc[i][j])
                
                for j in range(3):
                    tr.append(self.platform_pos[i][j])
                for j in range(3):
                    tr.append(self.platform_ang[i][j])
                for j in range(3):
                    tr.append(self.platform_lin_vel[i][j])
                for j in range(3):
                    tr.append(self.platform_ang_vel[i][j])
                for j in range(3):
                    tr.append(self.platform_lin_acc[i][j])
                for j in range(3):
                    tr.append(self.platform_ang_acc[i][j])

                if self.robot_env == 'solo':
                    for j in range(3):
                        tr.append(self.transformted_lin_acc_imu_data[i][j])
                    for j in range(3):
                        tr.append(self.imu_calc_angular_acceleration[i][j])
                
                if self.save_data:
                    self.data_writer.writerow(tr)   
                if self.save_history:
                    self.data_writer_c.writerow(tr)    
        
        if self.save_data:
            self.save_f.close()
            print("Saved Ouptut in file:",self.save_output_file_name)

        if self.save_history:
            self.save_f_c.close()
            print("Saved Ouptut in file:",self.save_output_file_name_c)


    def normalizeVector(self, vec):
        """
            Returns normalized vector.

            :param vec: Vector you want to normalize.
            :type vec: np.array([]).
            :return: Normalized vector.
            :rtype: ndarray.
        """
        return vec / np.linalg.norm(vec)

    
    def calculate_platform_vel_acc(self): 
        """
            Calculates position, velocity, and acceleration for platform using forward kinematics. 

            :return: None.
            :rtype: None.
        """
        # Convert all vectors to Z up system
        rotMatrix = Rotation.from_euler('xyz', [math.pi/2, 0, 0], degrees=False).as_matrix()
        self.vec_base = rotMatrix.dot(self.vec_base)
        self.vec_hip = rotMatrix.dot(self.vec_hip)
        self.vec_u_leg = rotMatrix.dot(self.vec_u_leg)
        self.vec_l_leg = rotMatrix.dot(self.vec_l_leg)

        progress = 0
        print('Calculating positions and orientations...', progress, '%', end='\r')
        # calculation of platform position
        for ti, current_motor_pos in enumerate(self.curr_jointAngles):
            progress = math.floor(ti/len(self.curr_jointAngles) * 100)
            print('Calculating positions and orientations...', progress, '%', end='\r')
            points = []
            points.append(self.calculateBallJointPosition([6,9,8], 'left_front', current_motor_pos))
            points.append(self.calculateBallJointPosition([7,11,10], 'right_front', current_motor_pos))
            points.append(self.calculateBallJointPosition([0,3,2], 'left_back', current_motor_pos))
            points.append(self.calculateBallJointPosition([1,5,4], 'right_back', current_motor_pos))
            
            vcross1 = points[3] - points[0]
            vcross2 = points[2] - points[1]

            vx = self.normalizeVector(points[0] - points[2])
            vy = self.normalizeVector(points[0] - points[1])
            vz = self.normalizeVector(np.cross(vcross2, vcross1))

            # calculate acceleration
            self.platform_curr_pos = points[0] + vcross1/2 - np.array([0, 0, 6.73])/1000 # assumed that the middle point is also the middle of the platform
            rotMatrix = Rotation.align_vectors([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [vx, vy, vz])[0].as_matrix()
            rotMatrix = rotMatrix.transpose()
            
            self.platform_curr_ang = Rotation.from_matrix(rotMatrix).as_euler('xyz', degrees=False)
            self.platform_curr_pos = np.array(self.platform_curr_pos) + rotMatrix.dot(self.point_on_platform)
        
            self.platform_pos_calc.append(self.platform_curr_pos)
            self.platform_ang_calc.append(self.platform_curr_ang)
        
        if not self.update_data:
            self.platform_pos.append(self.platform_target[:, :3])
            self.platform_ang.append(self.platform_target[:, 3:])
            self.platform_pos = self.platform_pos[0]
            self.platform_ang = self.platform_ang[0]
        else:
            self.platform_pos = self.platform_target[:, :3]
            self.platform_ang = self.platform_target[:, 3:6]

        print('Calculating positions and orientations...done   ')

        self.platform_pos_calc_raw = self.platform_pos_calc
        self.platform_ang_calc_raw = self.platform_ang_calc

        # filter position data
        print('Filtering position data...', end='\r')
        # self.find_cutoff_frequency(self.platform_pos_calc)
        self.platform_pos_calc = self.filter_data(self.platform_pos_calc)
        fc_lin = self.fc
        print('Filtering position data...done (cutoff frequency:', fc_lin, 'Hz)')

        print('Filtering orientation data...', end='\r')
        # self.find_cutoff_frequency(self.platform_ang_calc)
        self.platform_ang_calc = self.filter_data(self.platform_ang_calc)
        fc_ang = self.fc
        print('Filtering orientation data...done (cutoff frequency:', fc_ang, 'Hz)')
        # calculation of platform velocity
        for i in range(len(self.platform_pos_calc)):
            if i == 0:
                self.platform_curr_lin_vel = np.array([0,0,0])
                self.platform_curr_ang_vel = np.array([0,0,0])
                if not self.update_data:
                    self.platform_lin_vel.append(np.array([0,0,0]))
                    self.platform_ang_vel.append(np.array([0,0,0]))
                else:
                    self.platform_lin_vel = self.platform_target[:, 6:9]
                    self.platform_ang_vel = self.platform_target[:, 9:12]

            else:
                self.platform_curr_lin_vel = self.xyz_derivative(self.platform_pos_calc[i - 1], self.platform_pos_calc[i], self.dt)
                self.platform_curr_ang_vel = self.xyz_derivative(self.platform_ang_calc[i - 1], self.platform_ang_calc[i], self.dt)
                if not self.update_data:
                    self.platform_lin_vel.append(self.xyz_derivative(self.platform_pos[i - 1], self.platform_pos[i], self.dt))
                    self.platform_ang_vel.append(self.xyz_derivative(self.platform_ang[i - 1], self.platform_ang[i], self.dt))
            
            self.platform_lin_vel_calc.append(self.platform_curr_lin_vel)          
            self.platform_ang_vel_calc.append(self.platform_curr_ang_vel)          

        self.platform_lin_vel_calc_raw = self.platform_lin_vel_calc
        self.platform_ang_vel_calc_raw = self.platform_ang_vel_calc
        
        # filter velocity data
        print('Filtering linear velocity data...', end='\r')
        self.fc = fc_lin
        self.platform_lin_vel_calc = self.filter_data(self.platform_lin_vel_calc)
        print('Filtering linear velocity data...done')

        print('Filtering angular velocity data...', end='\r')
        self.fc = fc_ang
        self.platform_ang_vel_calc = self.filter_data(self.platform_ang_vel_calc)
        print('Filtering angular velocity data...done')        
            
        # calculation of platform acceleration
        for i in range(len(self.platform_lin_vel_calc)):
            if i == 0 or i == 1:
                self.platform_curr_lin_acc = np.array([0,0,0])
                self.platform_curr_ang_acc = np.array([0,0,0])
                if not self.update_data:
                    self.platform_lin_acc.append(np.array([0,0,0]))
                    self.platform_ang_acc.append(np.array([0,0,0]))
                else:
                    self.platform_lin_acc = self.platform_target[:, 12:15]
                    self.platform_ang_acc = self.platform_target[:, 15:18]
        
            else:
                self.platform_curr_lin_acc = self.xyz_derivative(self.platform_lin_vel_calc[i - 1], self.platform_lin_vel_calc[i], self.dt)
                self.platform_curr_ang_acc = self.xyz_derivative(self.platform_ang_vel_calc[i - 1], self.platform_ang_vel_calc[i], self.dt)
                if not self.update_data:
                    self.platform_lin_acc.append(self.xyz_derivative(self.platform_lin_vel[i - 1], self.platform_lin_vel[i], self.dt))
                    self.platform_ang_acc.append(self.xyz_derivative(self.platform_ang_vel[i - 1], self.platform_ang_vel[i], self.dt))

            self.platform_lin_acc_calc.append(self.platform_curr_lin_acc)          
            self.platform_ang_acc_calc.append(self.platform_curr_ang_acc)          

        self.platform_lin_acc_calc_raw = self.platform_lin_acc_calc
        self.platform_ang_acc_calc_raw = self.platform_ang_acc_calc

        # filter acceleration data
        print('Filtering linear acceleration data...', end='\r')
        self.fc = fc_lin
        self.platform_lin_acc_calc = self.filter_data(self.platform_lin_acc_calc)
        print('Filtering linear acceleration data...done')

        print('Filtering angular acceleration data...', end='\r')
        self.fc = fc_ang
        self.platform_ang_acc_calc = self.filter_data(self.platform_ang_acc_calc)
        print('Filtering angular acceleration data...done')

        self.platform_sys_time = self.time_data

        index = 0
        self.platform_lin_acc_calc = np.array(self.platform_lin_acc_calc)
        self.platform_lin_acc_calc_raw = np.array(self.platform_lin_acc_calc_raw)


    def calculateBallJointPosition(self, indices, leg, motor_positions):
        """
            Calculates ball joint position. 

            :param indices: List of motor indices for leg. 
            :type indices: List[int].
            :param leg: Name of leg. 
            :type leg: str.
            :param motor_positions: Current position of motor. 
            :type motor_positions: ndarray.
            :return: Vector pointing from base of SOLO robot to dummy foot link end-effector.
            :rtype: ndarray.
        """
        if leg == 'left_front':
            position = np.array([1, 1, 1])
            sign_hip_angle = 1
            sign_u_leg_angle = 1
            sign_l_leg_angle = 1
        elif leg == 'right_front':
            position = np.array([1, -1, 1])
            sign_hip_angle = -1
            sign_u_leg_angle = -1
            sign_l_leg_angle = -1
        elif leg == 'left_back':
            position = np.array([-1, 1, 1])
            sign_hip_angle = 1
            sign_u_leg_angle = 1
            sign_l_leg_angle = 1
        elif leg == 'right_back':
            position = np.array([-1, -1, 1])
            sign_hip_angle = -1
            sign_u_leg_angle = -1
            sign_l_leg_angle = -1
        else:
            exit()

        vec_base = self.vec_base * position
        vec_hip = self.vec_hip * position
        vec_u_leg = self.vec_u_leg * position
        vec_l_leg = self.vec_l_leg * position

        if self.robot_env == 'solo': # account for motor gearing
            hip_angle = float(motor_positions[indices[0]]) * sign_hip_angle / 9 
            u_leg_angle = float(motor_positions[indices[1]]) * sign_u_leg_angle / 9 
            l_leg_angle = float(motor_positions[indices[2]]) * sign_l_leg_angle / 9 
        else:
            hip_angle = float(motor_positions[indices[0]]) * sign_hip_angle
            u_leg_angle = float(motor_positions[indices[1]]) * sign_u_leg_angle
            l_leg_angle = float(motor_positions[indices[2]]) * sign_l_leg_angle
        
        hip_rotMatrix = Rotation.from_euler('xyz', [hip_angle, 0, 0], degrees=False).as_matrix()
        vec_hip = hip_rotMatrix.transpose().dot(vec_hip)

        u_leg_rotMatrix = Rotation.from_euler('xyz', [0, u_leg_angle, 0], degrees=False).as_matrix()
        u_leg_rotMatrix = u_leg_rotMatrix.dot(hip_rotMatrix)
        vec_u_leg = u_leg_rotMatrix.transpose().dot(vec_u_leg)

        l_leg_rotMatrix = Rotation.from_euler('xyz', [0, l_leg_angle, 0], degrees=False).as_matrix()
        l_leg_rotMatrix = l_leg_rotMatrix.dot(u_leg_rotMatrix)
        vec_l_leg = l_leg_rotMatrix.transpose().dot(vec_l_leg)
        
        return vec_base + vec_hip + vec_u_leg + vec_l_leg


    def xyz_derivative(self, curr, prev, dt):
        """
            Calculates derivative in xyz. 

            :param curr: List of current xyz. 
            :type curr: List[Float].
            :param prev: List of previous xyz. 
            :type prev: List[Float].
            :param dt: Change in time from previous to current. 
            :type dt: Float.
            :return: List of derivatives in xyz.
            :rtype: list[Float].
        """
        return [float((curr[0]-prev[0])/dt), float((curr[1]-prev[1])/dt), float((curr[2]-prev[2])/dt)] 
        

    def get_skew_symmetric(self, v):
        """
            Calculates skew symmetric matrix. 

            :param v: Input vector. 
            :type v: List[Float].
            :return: Skkew symmetric matrix.
            :rtype: ndarray. 
        """
        return np.array([   [0.0,     float(-v[2]),      float(v[1])    ], 
                            [float(v[2]),      0.0,      float(-v[0])   ],
                            [float(-v[2]),  float(v[0]),      0.0       ]   ], dtype=object)


    def butter_lowpass(self, fc, fs, order = 2):
        """
            Butter lowpass filter. 

            :param fc: Cutoff frequency.
            :type fc: int.
            :param fs: Sampling frequency.
            :type fs: int. 
            :param order: Order of polynomial.
            :type order: int.
            :return: Numerator (b) and denominator (a) polynomials of the IIR filter.
            :rtype: ndarray, ndarray. 
        """
        wn = fc/(fs/2)
        b, a = signal.butter(order, wn, btype='low', analog=False)
        return b, a


    def butter_lowpass_filtfilt(self, data, cutoff, fs, order = 2):
        """
            Applies butter lowpass filter forward and backward to signal. 

            :param data: Data to filter.
            :type data: ndarray.
            :param cutoff: Cutoff frequency.
            :type cutoff: int.
            :param fs: Sampling frequency.
            :type fs: int. 
            :param order: Order of polynomial.
            :type order: int.
            :return: The filtered output with the same shape as data.
            :rtype: ndarray. 
        """
        b, a = self.butter_lowpass(cutoff, fs, order=order)
        y = signal.filtfilt(b, a, data)
        return y

    
    def filter_savgol(self, data, cutoff, order = 3):
        """
            Applies savgol filter to signal. 

            :param data: Data to filter.
            :type data: ndarray.
            :param cutoff: Cutoff frequency.
            :type cutoff: int.
            :param order: Order of polynomial.
            :type order: int.
            :return: The filtered output with the same shape as data.
            :rtype: ndarray. 
        """
        yh = savgol_filter(data, cutoff, order)
        return yh


    def filter_data(self, data):
        """
            Returns filtered data. 

            :param data: Data to filter.
            :type data: ndarray.
            :return: Filtered data from applied filter in xyz.
            :rtype: List(List[Float]). 
        """
        result = []
        data = np.array(data)
        xvals = data[:, 0]
        yvals = data[:, 1]
        zvals = data[:, 2]

        self.fs = 1000
        self.fc = 50

        xvals = self.butter_lowpass_filtfilt(xvals, self.fc, self.fs)
        yvals = self.butter_lowpass_filtfilt(yvals, self.fc, self.fs)
        zvals = self.butter_lowpass_filtfilt(zvals, self.fc, self.fs)

        # print(self.fc)

        # xvals = self.filter_savgol(xvals, self.fc, 3)
        # yvals = self.filter_savgol(yvals, self.fc, 3)
        # zvals = self.filter_savgol(zvals, self.fc, 3)

        for i in range(len(xvals)):
            result.append([xvals[i], yvals[i], zvals[i]])

        return result


    def init_params_for_calculations(self):
        """
            Initializes parameters for calculations. 

            :return: None.
            :rtype: None.
        """
        self.fs = self.frequency 
        self.fc = 5
        self.dt = 1/self.frequency
        # velocity and acceleration of platform (geometric center)
        self.platform_curr_pos = np.zeros(3)
        self.platform_curr_ang = np.zeros(3)
        self.platform_curr_lin_vel = np.zeros(3)
        self.platform_curr_ang_vel = np.zeros(3)
        # for plotting and csv file
        self.platform_sys_time = []
        self.platform_sequence_number = []
        self.platform_pos = []
        self.platform_pos_calc = []
        self.platform_pos_calc_raw = []
        self.platform_ang = []
        self.platform_ang_calc = []
        self.platform_ang_calc_raw = []
        self.platform_lin_vel = []
        self.platform_lin_vel_calc = []
        self.platform_lin_vel_calc_raw = []
        self.platform_ang_vel = []
        self.platform_ang_vel_calc = []
        self.platform_ang_vel_calc_raw = []
        self.platform_lin_acc = []
        self.platform_lin_acc_calc = []
        self.platform_lin_acc_calc_raw = []
        self.platform_ang_acc = []
        self.platform_ang_acc_calc = []
        self.platform_ang_acc_calc_raw = []
        self.time_data = []

        self.time_data = self.time_stamp
        self.motor_positions = self.curr_jointAngles
        self.target_positions = self.target_jointAngles

        # Measurements from SW in calibration pose (global coordinates in Y up system)
        self.vec_base = np.array([32.65, 31, -87.5])/1000  # Vector from origin to hip joint
        self.vec_hip = np.array([161.95, 1.24, -13.94])/1000    # Vector from hip joint to upper leg joint
        self.vec_u_leg = np.array([-6.61, 162.52, -22.67])/1000  # Vector from upper leg joint to lower leg joint
        self.vec_l_leg = np.array([-6.33, 160.04, 5.22])/1000    # Vector from lower leg joint to ball bearing of platform


    def imu_data_transformation(self):
        """
            Transforms IMU data from position of imu to center of platfrom. 

            :return: None.
            :rtype: None.
        """
        print("Calculating IMU data transformation...", end='\r')
        # calculates angular acceleration from angular velocity. No need to do transformation because change of angle is same at imu and center of platform
        self.imu_angular_acceleration_calculation() 
        # transforms linear acceleration from imu position to center of platform position
        self.imu_linear_acceleration_transformation() 
        print("Calculating IMU data transformation...done")

    
    def imu_angular_acceleration_calculation(self):
        """
            Calculates angular acceleration from angular velocity. No need to do transformation because change of angle is same at imu and center of platform.

            :return: None.
            :rtype: None.
        """
        t_imu_calc_angular_acceleration = []
        for i in range(len(self.imu_data)):
            if i == 0:
                t_imu_calc_angular_acceleration.append([0.0,0.0,0.0])
            else:
                t_imu_calc_angular_acceleration.append(self.xyz_derivative(self.imu_data[i, 3:6], self.imu_data[i-1, 3:6], 1/1000))

        self.imu_calc_angular_acceleration = np.array(self.filter_data(t_imu_calc_angular_acceleration))


    def imu_linear_acceleration_transformation(self):
        """
            Transforms linear acceleration from imu position to center of platform position.

            :return: None.
            :rtype: None.
        """
        vec_imu = [0,0,-0.0616] # m // -61.6 mm from center of platfrom to imu
        vec_center_of_plat = [0,0,0] # m

        first_derivative = []
        second_derivative = []
        diff_array = []
        transformed_linear_acc = []

        self.imu_data[:,:3] = self.filter_data(self.imu_data[:,:3])

        diff_vec = np.array(vec_imu) - np.array(vec_center_of_plat) # m

        for i in range(len(self.imu_data)):
            platform_orn = self.platform_ang_calc[i]
            alpha, beta, gamma = platform_orn # roll, pitch, yaw of platfrom  
            rotation_matrix = list(Rotation.from_euler('xyz', [alpha, beta, gamma], degrees=False).as_matrix())
            vec = np.dot(rotation_matrix, diff_vec)
            diff_array.append(vec)
            if i == 0:
                first_derivative.append([0.0,0.0,0.0])
            else:
                first_derivative.append(self.xyz_derivative(diff_array[i], diff_array[i-1], float(1/1000)))

        first_derivative = self.filter_data(first_derivative)

        for i in range(len(self.imu_data)):
            if i == 0:
                second_derivative.append([0.0,0.0,0.0])
            else:
                second_derivative.append(self.xyz_derivative(first_derivative[i], first_derivative[i-1], float(1/1000)))

        second_derivative = self.filter_data(second_derivative)

        for i in range(len(self.imu_data)):
            raw_linear_acc = self.imu_data[i,:3] # m/s2 
            transformed_linear_acc.append(np.array(raw_linear_acc) + np.array(second_derivative[i])) # substracting the additional accelereration vector from center of platform to imu
        
        self.transformted_lin_acc_imu_data = np.array(self.filter_data(transformed_linear_acc))


if __name__ == "__main__":
    # data_env = [GLOBAL_OUTPUT_DIRECTORY+PYBULLET_DATA_OUTPUT_FILE_NAME, GLOBAL_OUTPUT_DIRECTORY+PYBULLET_CALCULATED_FILE_NAME, 'pybullet'] 
    data_env = [GLOBAL_OUTPUT_DIRECTORY+SOLO_DATA_OUTPUT_FILE_NAME, GLOBAL_OUTPUT_DIRECTORY+SOLO_CALCULATED_FILE_NAME , 'solo']
    
    parser = argparse.ArgumentParser(description='Debug options.')
    parser.add_argument('-plot',
                    '--plots',
                    action='store_true',
                    help='show all plots')

    ctrl_data = DataProcessClass(data_env[0], 
                            data_env[2], 
                            [0,0,0])

    '''
        Calling data preview class after data processing is completed.
    '''
    if parser.parse_args().plots:
        print("Loading data preview class.")
        DataPreviewClass(
            name_of_data_csv_file = data_env[0] ,
            name_of_calculated_csv_file = data_env[1] ,
            robot_env = data_env[2], # or pybullet
            plot_fr_joint_angles = True,
            plot_calculated_pos_data = True,
            plot_calculated_vel_data = True,
            plot_calculated_acc_data = True,
            plot_imu_data = True,
        )
