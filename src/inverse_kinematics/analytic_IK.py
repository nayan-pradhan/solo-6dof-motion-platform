import csv
from matplotlib import pyplot as plt
import numpy as np
import math
from scipy.spatial.transform import Rotation as R
import sys
sys.path.append('./')
from config import *

class AnalyticIKClass():
    def __init__(self, robot_environment = 'pybullet'):
        self.robot_environment = robot_environment

        self.data = []
        self.dummy_joints= [3, 7, 11, 15]

        self.read_from_csv(True)
        self.data = np.array(self.data)

        self.positions = self.data[:, :3]
        self.orientations = self.data[:, 3:]

        self.joint_targets = []

        '''debug'''
        self.joints_pb = self.read_from_csv_pb(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME, True, 2)  

        self.calc_IK()

    '''debug'''
    def read_from_csv_pb(self, path, header = False, num_headers=1):
        t_num_headers = num_headers
        f = open(path)
        data = []
        for line in csv.reader(f):
            if header:
                if path == GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME:
                    if line[0] == 'solo':
                        print("\n==============================================================")
                        print("ERROR: SEQUENCE WAS GENERATED FOR SOLO ENV (1000 HZ). EXITING!")
                        print("==============================================================\n")
                        exit(-1)
                t_num_headers -= 1
                if t_num_headers == 0:      
                    header = False
            else:
                temp = []
                for e in line:
                    try:
                        temp.append(float(e))
                    except:
                        temp.append(e)
                data.append(temp)
        f.close()
        return data

    def read_from_csv(self, header = False):
        f = open(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_PLATFORM_FILE_NAME, 'r')
        for line in csv.reader(f):
            if header:
                header = False
            else:
                temp = []
                for e in line:
                    try:
                        temp.append(float(e))
                    except:
                        temp.append(e)
                self.data.append(temp)
        f.close()

    def calc_IK(self):
        # Reference vectors in zero pose
        # Measurements from SW in calibration pose (global coordinates in Y up system)
        vec_base = np.array([32.65, 31, -87.5])  # Vector from origin to hip joint
        vec_hip = np.array([161.95, 1.24, -13.94])    # Vector from hip joint to upper leg joint
        vec_u_leg = np.array([-6.61, 162.52, -22.67])  # Vector from upper leg joint to lower leg joint
        vec_l_leg = np.array([-6.33, 160.04, 5.22])    # Vector from lower leg joint to ball bearing of platform
        # Convert to Z up system
        rot_matrix = R.from_euler('xyz', [math.pi/2, 0, 0], degrees=False).as_matrix()
        vec_base = rot_matrix.dot(vec_base)
        vec_hip = rot_matrix.dot(vec_hip)
        vec_u_leg = rot_matrix.dot(vec_u_leg)
        vec_l_leg = rot_matrix.dot(vec_l_leg)

        target_positions = []
        for pos, orn in zip(self.positions, self.orientations):
            target_positions.append(self.transform_platform_to_robot(pos, orn))

        progress = 0
        print('Calculating inverse kinematic...', progress, '%', end='\r')
        for ti, targets in enumerate(target_positions):
            progress = math.floor(ti/len(target_positions) * 100)
            print('Calculating inverse kinematic...', progress, '%', end='\r')
            joints = []
            for it, target in enumerate(targets):
                vec_intersection = np.array([0., 0., 0.])
                if it == 0: # front left
                    position = np.array([1, 1, 1])
                elif it == 1: # front right:
                    position = np.array([1, -1, 1])
                elif it == 2: # back left:
                    position = np.array([-1, 1, 1])
                elif it == 3: # back right:
                    position = np.array([-1, -1, 1])
                # vec_p1 = np.array([210., 87.5, 31.]) * position # upper leg joint
                vec_p1 = (vec_base + vec_hip) * position
                vec_p2 = target # ball joint position
                vec_p2 *= 1000

                vec_x1 = np.array([0., 0., 0.])
                x1, y1, z1 = vec_x1[0], vec_x1[1], vec_x1[2]
                r1 = self.vec_len(vec_u_leg)

                vec_x2 = vec_p2 - vec_p1
                x2, y2, z2 = vec_x2[0], vec_x2[1], vec_x2[2]
                r2 = self.vec_len(vec_l_leg)

                delta_x = x1 - x2
                delta_y = y1 - y2
                delta_z = z1 - z2

                aa = 1 + pow(delta_x / delta_z, 2)
                bb = 1 + pow(delta_y / delta_z, 2)
                cc = delta_x * delta_y / pow(delta_z, 2)
                dd = delta_x * (self.vec_pow(vec_x1, 2) + self.vec_pow(vec_x2, 2) + pow(r1, 2) - pow(r2, 2)) / pow(delta_z, 2) - 2 * x1 + 2 * z1 * delta_x / delta_z

                ee = delta_y * (self.vec_pow(vec_x1, 2) + self.vec_pow(vec_x2, 2) + pow(r1, 2) - pow(r2, 2)) / pow(delta_z, 2) - 2 * y1 + 2 * z1 * delta_y / delta_z

                ff = (self.vec_pow(vec_x1, 4) + self.vec_pow(vec_x2, 4) + 2 * self.vec_pow(vec_x1, 2) * self.vec_pow(vec_x2, 2) + 2 * self.vec_pow(vec_x1, 2) * (pow(r1, 2) - pow(r2, 2)) + 2 * self.vec_pow(vec_x2, 2) * (pow(r1, 2) - pow(r2, 2)) + pow(r1, 4) + pow(r2, 4) - 2 * pow(r1, 2) * pow(r2, 2)) / (4 * pow(delta_z, 2)) + self.vec_pow(vec_x1, 2) * (1 + z1 / delta_z) + self.vec_pow(vec_x2, 2) * z1 / delta_z + pow(r1, 2) * (z1 / delta_z - 1) - pow(r2, 2) * z1 / delta_z


                aaa = aa - pow(cc, 2) / bb
                bbb = dd - cc * ee / bb
                ccc = -pow(ee, 2) / 4 / bb + ff

                try:
                    res_x_1 = (-bbb + math.sqrt(pow(bbb, 2) - 4 * aaa * ccc))/(2 * aaa)
                    res_x_2 = (-bbb - math.sqrt(pow(bbb, 2) - 4 * aaa * ccc))/(2 * aaa)
                except:
                    print('negative square root!')
                    exit(-1)

                # calculate y value (x value in eq VI)
                res_y_1 = (-2 * cc * res_x_1 - ee) / (2 * bb)
                res_y_2 = (-2 * cc * res_x_2 - ee) / (2 * bb)

                # calculate z value (x, y values in eq IV)
                res_z_1 = (-2 * res_x_1 * delta_x - 2 * res_y_1 * delta_y - self.vec_pow(vec_x1, 2) - self.vec_pow(vec_x2, 2) - pow(r1, 2) + pow(r2, 2)) / (2 * delta_z)
                res_z_2 = (-2 * res_x_2 * delta_x - 2 * res_y_2 * delta_y - self.vec_pow(vec_x1, 2) - self.vec_pow(vec_x2, 2) - pow(r1, 2) + pow(r2, 2)) / (2 * delta_z)

                # save results in vector and translate back to gobal system
                vec_intersection_1 = np.array([res_x_1, res_y_1, res_z_1]) + vec_p1
                vec_intersection_2 = np.array([res_x_2, res_y_2, res_z_2]) + vec_p1

                # final intersection vector will be the one closest to 0 in x direction --> knee bend inwards
                vec_intersection = vec_intersection_1 if abs(vec_intersection_1[0]) < abs(vec_intersection_2[0]) else vec_intersection_2


                # calculate new vectors to intersection point
                vec_hip_to_knee = vec_intersection - vec_p1
                vec_knee_to_ball_joint = vec_p2 - vec_intersection

                # calculate hip angle
                vec_0 = np.array([vec_u_leg[1] * position[1], vec_u_leg[2] * position[2]])
                vec_0 = self.normalize_vector(vec_0)
                vec_1 = np.array([vec_hip_to_knee[1], vec_hip_to_knee[2]])
                vec_1 = self.normalize_vector(vec_1)
                hip_angle = math.acos(vec_0.dot(vec_1))
                if vec_0[0] < vec_1[0]:
                    hip_angle *= -1

                hip_rot_matrix = R.from_euler('xyz', [hip_angle, 0, 0], degrees=False).as_matrix()

                # calculate upper leg angle
                vec_0 = np.array([vec_u_leg[0] * position[0], vec_u_leg[2] * position[2]])
                vec_0 = self.normalize_vector(vec_0)
                vec_1 = hip_rot_matrix.dot(vec_hip_to_knee) # rotate to zero hip angle
                vec_1 = np.array([vec_1[0], vec_1[2]])
                vec_1 = self.normalize_vector(vec_1)
                u_leg_angle = math.acos(vec_0.dot(vec_1))
                u_leg_rot_matrix = R.from_euler('xyz', [0, u_leg_angle, 0], degrees=False).as_matrix()

                # calculate upper leg angle
                vec_0 = np.array([vec_l_leg[0] * position[0], vec_l_leg[2] * position[2]])
                vec_0 = self.normalize_vector(vec_0)
                rot_matrix = u_leg_rot_matrix.dot(hip_rot_matrix)
                vec_1 = rot_matrix.dot(vec_knee_to_ball_joint) # rotate to zero hip angle
                vec_1 = np.array([vec_1[0], vec_1[2]])
                vec_1 = self.normalize_vector(vec_1)
                l_leg_angle = math.acos(vec_0.dot(vec_1))
                if vec_0[0] < vec_1[0] or vec_0[1] < vec_1[1]:
                    l_leg_angle *= -1

                if it == 0: # front left
                    joints.append(-hip_angle)
                    joints.append(u_leg_angle)
                    joints.append(l_leg_angle)
                elif it == 1: # front right
                    joints.append(-hip_angle)
                    joints.append(-u_leg_angle)
                    joints.append(-l_leg_angle)
                elif it == 2: # back left
                    joints.append(hip_angle)
                    joints.append(-u_leg_angle)
                    joints.append(l_leg_angle + math.pi/2)
                elif it == 3: # back right
                    joints.append(hip_angle)
                    joints.append(u_leg_angle)
                    joints.append(l_leg_angle - math.pi/2)
                joints.append(0.)

            self.joint_targets.append(joints)

        print('Calculating inverse kinematic...done   ')

        print('Saving data to csv...', end='\r')
        f = open(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME, 'w')
        if self.robot_environment == "pybullet":
            fn = "pybu" 
        else:
            fn = "solo"
        # fc = open(GLOBAL_AUTOGENERATED_DIRECTORY + HISTORY_DIR + fn + '_' + TRAJ_JOINTS_FILE_UNIQUE, 'w')
        writer = csv.writer(f)
        # writerc = csv.writer(fc)
        writer.writerow([self.robot_environment])
        # writerc.writerow([self.robot_environment])

        header_line = [
            "fl_hip", "fl_upper", "fl_lower", "fl_dummy", 
            "fr_hip", "fr_upper", "fr_lower", "fr_dummy",
            "bl_hip", "bl_upper", "bl_lower", "bl_dummy",
            "br_hip", "br_upper", "br_lower", "br_dummy"
            ]

        writer.writerow(header_line)
        # writerc.writerow(header_line)

        writer.writerows(self.joint_targets[1:])
        # writerc.writerows(joint_positions[1:])
        # fc.close()
        f.close()
        print('Saving data to csv...done')
        

        # self.compare()

    def compare(self):
        self.joint_targets = np.array(self.joint_targets)
        self.joints_pb = np.array(self.joints_pb)
        fig, axs = plt.subplots(4, 3)
        axs[0, 0].plot(self.joint_targets[:, 0], label='analytic')
        axs[0, 1].plot(self.joint_targets[:, 1], label='analytic')
        axs[0, 2].plot(self.joint_targets[:, 2], label='analytic')
        axs[1, 0].plot(self.joint_targets[:, 4], label='analytic')
        axs[1, 1].plot(self.joint_targets[:, 5], label='analytic')
        axs[1, 2].plot(self.joint_targets[:, 6], label='analytic')
        axs[2, 0].plot(self.joint_targets[:, 8], label='analytic')
        axs[2, 1].plot(self.joint_targets[:, 9], label='analytic')
        axs[2, 2].plot(self.joint_targets[:, 10], label='analytic')
        axs[3, 0].plot(self.joint_targets[:, 12], label='analytic')
        axs[3, 1].plot(self.joint_targets[:, 13], label='analytic')
        axs[3, 2].plot(self.joint_targets[:, 14], label='analytic')
        # axs[4, 0].plot(self.joint_targets[:, [0, 4, 8, 12]], label=['fl', 'fr', 'bl', 'br'])
        # axs[4, 1].plot(self.joint_targets[:, [1, 5, 9, 13]], label=['fl', 'fr', 'bl', 'br'])
        # axs[4, 2].plot(self.joint_targets[:, [2, 6, 10, 14]], label=['fl', 'fr', 'bl', 'br'])

        axs[0, 0].plot(self.joints_pb[:, 0], label='pb IK')
        axs[0, 1].plot(self.joints_pb[:, 1], label='pb IK')
        axs[0, 2].plot(self.joints_pb[:, 2], label='pb IK')
        axs[1, 0].plot(self.joints_pb[:, 4], label='pb IK')
        axs[1, 1].plot(self.joints_pb[:, 5], label='pb IK')
        axs[1, 2].plot(self.joints_pb[:, 6], label='pb IK')
        axs[2, 0].plot(self.joints_pb[:, 8], label='pb IK')
        axs[2, 1].plot(self.joints_pb[:, 9], label='pb IK')
        axs[2, 2].plot(self.joints_pb[:, 10], label='pb IK')
        axs[3, 0].plot(self.joints_pb[:, 12], label='pb IK')
        axs[3, 1].plot(self.joints_pb[:, 13], label='pb IK')
        axs[3, 2].plot(self.joints_pb[:, 14], label='pb IK')
        # axs[4, 0].plot(self.joints_pb[:, [0, 4, 8, 12]], label='pb IK')
        # axs[4, 1].plot(self.joints_pb[:, [1, 5, 9, 13]], label='pb IK')
        # axs[4, 2].plot(self.joints_pb[:, [2, 6, 10, 14]], label='pb IK')


        plt.legend()
        plt.show()


    def transform_platform_to_robot(self, platform_pos, platform_orn):
        target_pos = []
        ball_joint_pos = []
        joint_pos_platform = np.array([181.65, 118.89, 6.73])/1000   # relative Position of ball joint to origin

        # calculate ball joint positions on platform
        rot_matrix = self.get_rotation_matrix(platform_orn)
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([1, -1, 1])))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([-1, 1, 1])))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([-1, -1, 1])))

        for ball_joint in ball_joint_pos:
            target_pos.append(platform_pos + ball_joint)

        return target_pos

    def get_rotation_matrix(self, orientation):
        # Euler
        if len(orientation) == 3:
            return R.from_euler('xyz', orientation, degrees=False).as_matrix()
        elif len(orientation) == 4:
            return R.from_quat(orientation).as_matrix()
        else:
            print('wrong input for orientation.')
            exit()

    def vec_pow(self, vec, pow):
        res = vec.dot(vec)
        if pow == 2:
            return res
        elif pow == 4:
            return res * res
        else:
            print('power must be 2 or 4')
            exit(-1)

    def vec_len(self, vec):
        res = 0
        for e in vec:
            res += e**2
        res = math.sqrt(res)
        return res

    def normalize_vector(self, vec):
        return vec / np.linalg.norm(vec)


if __name__ == '__main__':
    AnalyticIKClass()