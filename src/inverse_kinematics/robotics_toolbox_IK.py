import csv
from matplotlib import pyplot as plt
import numpy as np
import roboticstoolbox as rtb
from roboticstoolbox.robot.ERobot import ERobot
from scipy.spatial.transform import Rotation as R
from scipy.interpolate import interp1d
from os import getcwd, chdir
import sys
sys.path.append('./')
from config import *
from spatialmath import SE3

class RoboticsToolboxIKClass():
    def __init__(self, robot_environment = ''):
        self.robot_environment = robot_environment

        self.data = []
        self.dummy_joints= [3, 7, 11, 15]

        self.read_from_csv(True)
        self.data = np.array(self.data)

        self.positions = self.data[:, :3]
        self.orientations = self.data[:, 3:]

        self.joint_targets = []

        self.solo = Solo()
        # self.solo.plot(q_temp, 'pyplot')
        print(self.solo)
        
        self.calc_IK()

    def read_from_csv(self, header = False):
        f = open(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_PLATFORM_FILE_NAME, 'r')
        for line in csv.reader(f):
            if header:
                header = False
            else:
                temp = []
                for e in line:
                    try:
                        temp.append(float(e))
                    except:
                        temp.append(e)
                self.data.append(temp)
        f.close()

    def calc_IK(self):
        joint_positions = [] 
        initial_joint_pos = [-0.03720331288427462,0.829007129122855,-1.6202734972969408,0.0,0.034261802256937444,-0.8275962751091314,1.617652654183728,0.0,0.03734524762342967,-0.8291123597545643,1.6206753705804764,0.0,-0.03441818042258571,0.8276649022998361,-1.6178770197057506,0.0]
        last_joint_pos = initial_joint_pos
        temp = 0
        target_positions = []

        for pos, orn in zip(self.positions, self.orientations):
            target_positions.append(self.transform_platform_to_robot(pos, orn))

        target_positions = np.array(target_positions)

        start_pos = np.array([181.65, 117.69, 354.8])/1000
        interp = np.arange(0, 1, .001)

        f = interp1d([0, 1], [start_pos, target_positions[0, 0]], axis=0)
        traj_dummy = f(interp)


        '''
        traj = []
        for pos in traj_dummy:
            traj.append(SE3(pos[0], pos[1], pos[2]))
        traj = np.array(traj)
        
        self.solo.q = np.zeros(16)
        for pos in traj_dummy:
            q = []
            se3_pos = SE3(pos[0], pos[1], pos[2])
            # calc inverse kinematics
            # res = self.solo.ik_gn(
            #     Tep= se3_pos,
            #     end=self.solo.ee_links[0],
            #     q0=self.solo.q,
            #     ilimit=100000,
            #     slimit=10,
            #     we=[1, 1, 1, 0, 0, 0],
            # )    
            res = self.solo.ikine_LM(
                    T=traj,
                    q0=self.solo.q,
                    mask=[1, 1, 1, 0, 0, 0],
                    ilimit=1e5
            )

            # fill q array
            for e in res[0]:
                q.append(e)
            while len(q) < 16:
                q.append(0.)
            self.solo.q = q
            
            print(res)
            if res[1] == 0:
                break
            traj.append(q)
            
        '''
        traj = []
        pos = [-3.312884274744904e-06, 0.8092671291228548, -1.5993534972969403, 0., 1.8022569373101534e-06, -0.8092662751091312, 1.599352654183728,0., 2.4762342988659546e-07, -0.8092613597545637, 1.5993453705804668,0., -1.8042258585540595e-07, 0.8092669022998362, -1.599357019705762, 0.]
        for i in range(100):
            traj.append(pos)


        traj = np.array(traj)

        self.solo.plot(traj, 'pyplot')

        exit(-1)
        print('Saving data to csv...', end='\r')
        f = open(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME, 'w')
        if self.robot_environment == "pybullet":
            fn = "pybu" 
        else:
            fn = "solo"
        fc = open(GLOBAL_AUTOGENERATED_DIRECTORY + HISTORY_DIR + fn + '_' + TRAJ_JOINTS_FILE_UNIQUE, 'w')
        writer = csv.writer(f)
        writerc = csv.writer(fc)
        writer.writerow([self.robot_environment])
        writerc.writerow([self.robot_environment])

        header_line = [
            "fl_hip", "fl_upper", "fl_lower", "fl_dummy", 
            "fr_hip", "fr_upper", "fr_lower", "fr_dummy",
            "bl_hip", "bl_upper", "bl_lower", "bl_dummy",
            "br_hip", "br_upper", "br_lower", "br_dummy"
            ]

        writer.writerow(header_line)
        writerc.writerow(header_line)

        writer.writerows(joint_positions[1:])
        writerc.writerows(joint_positions[1:])
        fc.close()
        f.close()
        print('Saving data to csv...done')

    def transform_platform_to_robot(self, platform_pos, platform_orn):
        target_pos = []
        ball_joint_pos = []
        joint_pos_platform = np.array([181.65, 118.89, 6.73])/1000   # relative Position of ball joint to origin

        # calculate ball joint positions on platform
        rot_matrix = self.get_rotation_matrix(platform_orn)
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([1, -1, 1])))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([-1, 1, 1])))
        ball_joint_pos.append(rot_matrix.dot(joint_pos_platform * np.array([-1, -1, 1])))

        for ball_joint in ball_joint_pos:
            target_pos.append(platform_pos + ball_joint)

        return target_pos

    def get_rotation_matrix(self, orientation):
        # Euler
        if len(orientation) == 3:
            return R.from_euler('xyz', orientation, degrees=False).as_matrix()
        elif len(orientation) == 4:
            return R.from_quat(orientation).as_matrix()
        else:
            print('wrong input for orientation.')
            exit()


class Solo(ERobot):

    def __init__(self):
        # save current working directory
        cwd = getcwd()
        
        # change cwd to resources
        chdir('../resources')
        links, name, urdf_string, urdf_filepath = self.URDF_read(
            "URDF_motion_simulator_simplified_dummy/urdf/URDF_motion_simulator_simplified_dummy.urdf"
        )

        # reset to start working directory
        chdir(cwd)
        
        super().__init__(
            links,
            name=name.upper(),
            manufacturer='Custom Unamed'
        )

if __name__ == '__main__':
    RoboticsToolboxIKClass()