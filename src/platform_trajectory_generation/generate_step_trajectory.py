"""
    Python script to generate step trajectory
"""

import csv
import numpy as np 
from platform_trajectory_generation.generate_arbitrary_trajectory import *

class GenerateStepTrajectory_CSV_Class():

    def __init__(self,
        path_to_input_file = GLOBAL_INPUT_DIRECTORY,
        input_file_name = '',
        frequency = 240,
        stop_time = 2,
        threshold_amplitude = THRESHOLD_AMPLITUDE
    ):
        self.threshold_amplitude = threshold_amplitude
        if input_file_name == '':
            print("Input file name is empty!")
            exit(-1)
        input_file_name = path_to_input_file + input_file_name
        arbitrary_sequences = self.read_from_csv(file_name=input_file_name)

        prev_pos = [0.0,0.0,0.0] # home offset added in program later
        prev_orn = [0.0,0.0,0.0] # home offset added in program later
        home_pos = [0,0,0.25] # default
        home_orn = [0,0,0] # default

        GenerateArbitraryTrajectoryClass( # wait at home pos before step function
                flush = True, 
                trajectory_frequency = frequency,
                start_pos_xyz = prev_pos,
                start_orn_xyz = prev_orn,
                end_pos_xyz = prev_pos,
                end_orn_xyz = prev_orn,
                interpolate_time=stop_time,
            )

        for si, arbitrary_sequence in enumerate(arbitrary_sequences):
            f = False 

            local_start_pos_xyz = []
            local_start_orn_xyz = []
            local_end_pos_xyz = []
            local_end_orn_xyz = []

            try:
                for xyz_i in range(3):
                    local_start_pos_xyz.append(prev_pos[xyz_i])
                    local_start_orn_xyz.append(prev_orn[xyz_i])
                    local_end_pos_xyz.append(arbitrary_sequence[xyz_i])
                    local_end_orn_xyz.append(arbitrary_sequence[xyz_i+3])
            except:
                print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
                print("ERROR:Check arbitrary input file. Input incorrect!")
                print("Exiting")
                print("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
                exit(-1)

            self.file = open(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_PLATFORM_FILE_NAME, 'a') 
            self.data_writer = csv.writer(self.file)

            for j in range(stop_time * frequency):
                self.data_writer.writerow([*np.array(local_end_pos_xyz) + np.array(home_pos), *np.array(local_end_orn_xyz) + np.array(home_orn)])

            prev_pos = local_end_pos_xyz
            prev_orn = local_end_orn_xyz


    def are_arrays_same(self, arr1, arr2):
        """
            Checks if two arrays have same size and elements. 

            :param arr1: First array.
            :type arr1: list[].
            :param arr1: Second array.
            :type arr1: list[].
            :return: True if arrays are same, False if arrays are different.
            :rtype: Bool.
        """
        if len(arr1) != len(arr2):
            return False 
        for i in range(len(arr1)):
            if arr1[i] != arr2[i]:
                return False 
        return True

            
    def read_from_csv(self, file_name='', header=True):
        """
            Reads from csv file.

            :param file_name: Name of csv file. 
            :param type: String. 
            :param header: True if csv file contains header, False if csv file does not contain header.
            :return: Returns all lines from csv file.
            :rtype: list[ [[],[],..], [[],[],..], .. ].
        """
        self.r_file = open(file_name)
        csv_reader = csv.reader(self.r_file)
        lines = []
        for line in csv_reader:
            temp = []
            for elem_i, elem in enumerate(line):
                try:
                    if elem_i < 3:
                        if float(elem) > self.threshold_amplitude:
                            print("- End pos " + str(elem) + "mm is larger than tested mm threshold of solo robot of "+str(self.threshold_amplitude) + "mm. Using maximum threshold ("+ 
                                str(self.threshold_amplitude) +" mm) instead.")
                            temp.append(float(self.threshold_amplitude)/1000)
                        elif float(elem) < -self.threshold_amplitude:
                            print("- End pos " + str(elem) + "mm is smaller than tested mm threshold of solo robot of -"+str(self.threshold_amplitude) + "mm. Using minimum threshold (-"+ 
                                str(self.threshold_amplitude) +" mm) instead.")
                            temp.append(-1*float(self.threshold_amplitude)/1000)
                        else:
                            temp.append(float(elem) / 1000) # convert mm to m

                    else:
                        if float(elem) > self.threshold_amplitude:
                            print("- End orn " + str(elem) + "deg is larger than tested deg threshold of solo robot of "+str(self.threshold_amplitude) + "deg. Using maximum threshold ("+ 
                                str(self.threshold_amplitude) +" deg) instead.")
                            temp.append(float(math.radians(self.threshold_amplitude)))
                        elif float(elem) < -self.threshold_amplitude:
                            print("- End orn " + str(elem) + "deg is smaller than tested deg threshold of solo robot of -"+str(self.threshold_amplitude) + "deg. Using minimum threshold (-"+ 
                                str(self.threshold_amplitude) +" deg) instead.")
                            temp.append(float(-1*(math.radians(self.threshold_amplitude))))
                        else:
                            temp.append(math.radians(float(elem))) # conver deg to rad
                except:
                    temp.append(elem)
            lines.append(temp)
        if header:
            lines = lines[1:] # cut out title line in csv file
        return lines # limited to only the latest step


if __name__ == '__main__':
    GenerateStepTrajectory_CSV_Class()