"""
    Python script to generate sine trajectory
"""

import csv
import numpy as np 
from scipy.interpolate import interp1d
import math
from matplotlib import pyplot as plt

from config import *

class GenerateSineTrajectoryClass():

    def __init__(self,
        input_file_name = '',
        output_file_name = TRAJ_PLATFORM_FILE_NAME,
        frequency = 240,
        interpolate_time = 0.1, # s
        home_pos = [0,0,0.25],
        home_orn = [0,0,0], 
        threshold_frequency = THRESHOLD_FREQUENCY, 
        threshold_amplitude = THRESHOLD_AMPLITUDE,
    ):
        if input_file_name == '':
            print("Input file name is empty!")
            exit(-1)
            
        self.interpolate_time = interpolate_time
        self.frequency = frequency
        self.home_pos = home_pos
        self.home_orn = home_orn
        self.threshold_frequency = threshold_frequency
        self.threshold_amplitude = threshold_amplitude

        output_file_name = GLOBAL_AUTOGENERATED_DIRECTORY+output_file_name

        input_file_name = GLOBAL_INPUT_DIRECTORY + input_file_name
        motion_sequences = []
        dt = 1/self.frequency

        output_trajectory = []

        motion_sequences = self.read_from_csv(file_name=input_file_name)

        self.global_sequence_number = 0

        if len(motion_sequences) == 0:
            print("SEQUENCE EMPTY - ADDING EMPTY SEQUENCE")
            motion_sequences.append(['10', '10', 'x', 't', '0', '0', '0', '0', '0'])
        
        for sequence_number, motion_sequence_i in enumerate(motion_sequences):
            self.global_sequence_number = sequence_number
            self.sequence_run_time = int(motion_sequence_i[0])
            self.sequence_wait_time = int(motion_sequence_i[1])
            sequence_direction = motion_sequence_i[2]
            sequence_motion_type = motion_sequence_i[3]
            self.sequence_frequency = float(motion_sequence_i[4])
            self.sequence_amplitude = float(motion_sequence_i[5])
            sequence_offset_x = float(motion_sequence_i[6]) / 1000
            sequence_offset_y = float(motion_sequence_i[7]) / 1000
            sequence_offset_z = float(motion_sequence_i[8]) / 1000

            end_steps = self.sequence_run_time
            self.step_size = dt
            self.sin_x = np.arange(0, end_steps, self.step_size)

            if (self.sequence_frequency > self.threshold_frequency):
                print("- Input frequency " + str(self.sequence_frequency) + "Hz for sequence " + str(self.global_sequence_number) + ", " + str(sequence_direction) + ", " + str(sequence_motion_type) +
                 " is larger than tested frequency threshold of solo robot of "+str(self.threshold_frequency) + " Hz. Using maximum threshold frequency ("+ 
                 str(self.threshold_frequency) +" Hz) instead.")
                self.sequence_frequency = self.threshold_frequency

            if (self.sequence_frequency < -self.threshold_frequency):
                print("- Input frequency " + str(self.sequence_frequency) + "Hz for sequence " + str(self.global_sequence_number) + ", " + str(sequence_direction) + ", " + str(sequence_motion_type) +
                 " is smaller than tested frequency threshold of solo robot of "+str(self.threshold_frequency) + " Hz. Using minimum threshold frequency (-"+ 
                 str(self.threshold_frequency) +" Hz) instead.")
                self.sequence_frequency = -1 * self.threshold_frequency

            if (self.sequence_amplitude > self.threshold_amplitude):
                print("- Input amplitude " + str(self.sequence_amplitude) + "mm/deg for sequence " + str(self.global_sequence_number) + ", " + str(sequence_direction) + ", " + str(sequence_motion_type) +
                 " is larger than tested amplitude threshold of solo robot of "+str(self.threshold_amplitude) + " mm/deg. Using maximum threshold amplitude ("+ 
                 str(self.threshold_amplitude) +" mm/deg) instead.")
                self.sequence_amplitude = self.threshold_amplitude

            if (self.sequence_amplitude < -self.threshold_amplitude):
                print("- Input amplitude " + str(self.sequence_amplitude) + "mm/deg for sequence " + str(self.global_sequence_number) + ", " + str(sequence_direction) + ", " + str(sequence_motion_type) +
                 " is smaller than tested amplitude threshold of solo robot of "+str(self.threshold_amplitude) + " mm/deg. Using minimum threshold amplitude (-"+ 
                 str(self.threshold_amplitude) +" mm/deg) instead.")
                self.sequence_amplitude = -1 * self.threshold_amplitude

            if sequence_direction == 'x':
                if sequence_motion_type == 't':
                    self.current_movement_axis = 0
                elif sequence_motion_type == 'r':
                    self.current_movement_axis = 3
                else:
                    print("Motion type invalid.")
                    self.current_movement_axis = None
                currentAxis = [1, 0, 0]

            elif sequence_direction == 'y':
                if sequence_motion_type == 't':
                    self.current_movement_axis = 1  
                elif sequence_motion_type == 'r':
                    self.current_movement_axis = 4
                else:
                    print("Motion type invalid.")
                    self.current_movement_axis = None
                currentAxis = [0, 1, 0]

            elif sequence_direction == 'z':
                if sequence_motion_type == 't':
                    self.current_movement_axis = 2
                elif sequence_motion_type == 'r':
                    self.current_movement_axis = 5
                else:
                    print("Motion type invalid.")
                    self.current_movement_axis = None
                currentAxis = [0, 0, 1]
            
            else:
                print("MOVEMENT AXIS NOT SPECIFIED/INVALID")
                currentAxis = [0, 0, 0]
                self.current_movement_axis = None

            if sequence_motion_type == 't':
                # convert mm to m
                self.sequence_amplitude = self.sequence_amplitude/1000
            
            elif sequence_motion_type == 'r':
                # convert degree to rad 
                self.sequence_amplitude = math.radians(self.sequence_amplitude)

            self.currentAxisPos = np.array([sequence_offset_x, sequence_offset_y, sequence_offset_z])
            p, o = self.desiredPlatformPosOrn()

            temppo = np.vstack([p, o])

            if self.global_sequence_number == 0:
                output_trajectory = temppo
            else:
                output_trajectory = np.hstack([output_trajectory, temppo])
        
        output_trajectory = np.array(output_trajectory).T

        print("Complete trajectory generated for input sequence.")
        self.r_file.close()

        ii, jj = np.shape(output_trajectory)

        self.open_csv_for_write(file_name=output_file_name, write_mode='w')

        print("Writing...")
        for i in range(ii):
            self.write_csv_row(np.array(output_trajectory[i]))
        self.w_file.close()

        print("Write complete, csv saved.")


    def transformVector(self, vec, dir, inverse):
        """
            Returns transformed vector.

            :param vec: Vector you want to transform.
            :type vec: np.array([]).
            :param dir: Direction of rotation.
            :type dir:  np.array([]).
            :param inverse: Option to transpose rotation matrix.
            :type inverse: Bool.
            :return: Transformed vector.
            :rtype: ndarray.
        """
        result = []
        rotMatrix = self.getRotationMatrix(dir)
        if inverse:
            rotMatrix = rotMatrix.transpose()
        result = rotMatrix.dot(vec)
        return result


    def getRotationMatrix(self, orientation):
        """
            Returns rotation matrix calculated with orientation value.

            :param orientation: Orientation of platform.
            :type orientation: list[float].
            :return: Retuns rotation matrix.
            :rtype: ndarray.
        """
        alpha = orientation[0]
        beta = orientation[1]
        gamma = orientation[2]

        xRotation = np.array([[1, 0, 0],[0, math.cos(alpha), -math.sin(alpha)], [0, math.sin(alpha), math.cos(alpha)]])
        yRotation = np.array([[math.cos(beta), 0, math.sin(beta)], [0, 1, 0], [-math.sin(beta), 0, math.cos(beta)]])
        zRotation = np.array([[math.cos(gamma), -math.sin(gamma), 0], [math.sin(gamma), math.cos(gamma), 0], [0, 0, 1]])

        r_mat = zRotation.dot(yRotation).dot(xRotation)

        return r_mat


    def desiredPlatformPosOrn(self):
        """
            Generates, combines, and returns all required translational and rotational platform trajectory.

            :return: Returns complete platform translation and rotation trajectory.
            :rtype: [ndarray, ndarray].
        """
        f_translation = []
        f_rotation = []

        if self.global_sequence_number == 0:
            ''' Initial waiting time trajectory in home pos '''
            home_waiting_traj_translation = [None] * 3
            home_waiting_traj_rotation = [None] * 3
            home_waiting_traj_translation[0] = self.get_interpolated_traj(start=self.home_pos[0], end=self.home_pos[0], time_t=2)
            home_waiting_traj_translation[1] = self.get_interpolated_traj(start=self.home_pos[1], end=self.home_pos[1], time_t=2)
            home_waiting_traj_translation[2] = self.get_interpolated_traj(start=self.home_pos[2], end=self.home_pos[2], time_t=2)
            home_waiting_traj_rotation[0] = self.get_interpolated_traj(start=self.home_orn[0], end=self.home_orn[0], time_t=2)
            home_waiting_traj_rotation[1] = self.get_interpolated_traj(start=self.home_orn[1], end=self.home_orn[1], time_t=2)
            home_waiting_traj_rotation[2] = self.get_interpolated_traj(start=self.home_orn[2], end=self.home_orn[2], time_t=2)

        ''' Sequence i trajectory '''
        sin_amp = np.sin(self.sin_x * (2*math.pi) * self.sequence_frequency) * self.sequence_amplitude
        sequence_traj_translation = [[],[],[]]
        sequence_traj_rotation = [[],[],[]]

        if self.current_movement_axis is None: 
            pass
        elif self.current_movement_axis < 3:
            t_t = []
            for i in range(len(self.sin_x)):
                t_t.append(sin_amp[i])
            for ci in range(3):
                if ci != self.current_movement_axis:
                    sequence_traj_translation[ci] = ([0.0]*len(self.sin_x))
                    
                else:
                    sequence_traj_translation[ci] = (t_t)
                sequence_traj_rotation[ci] = ([0.0]*len(self.sin_x))

        elif self.current_movement_axis > 2 and self.current_movement_axis < 6:
            t_r = [] 
            for j in range(len(self.sin_x)):
                t_r.append(sin_amp[j])
            for cj in range(3):
                if cj != self.current_movement_axis%3:
                    sequence_traj_rotation[cj] = ([0.0]*len(self.sin_x))
                else:
                    sequence_traj_rotation[cj] = t_r
                sequence_traj_translation[cj] = ([0.0]*len(self.sin_x))
            sequence_traj_rotation = np.array(sequence_traj_rotation)
            for tj in range(np.shape(sequence_traj_rotation)[1]):
                if tj == 0:
                    oldVec = self.currentAxisPos
                newVec = self.transformVector(oldVec, sequence_traj_rotation[:,tj], True)
                for ttt in range(3): 
                    sequence_traj_translation[ttt][tj] = oldVec[ttt] - newVec[ttt]

                oldVec = newVec

        sequence_traj_translation = np.array(sequence_traj_translation)
        sequence_traj_translation += np.array([self.home_pos] * (np.shape(sequence_traj_translation)[1])).T # adding home pos to sequence_traj_translation

        ''' Interpolation to home pos trajectory '''
        interpolated_traj_translation = [None] * 3
        interpolated_traj_rotation = [None] * 3

        interpolated_traj_translation[0] = self.get_interpolated_traj(start=sequence_traj_translation[0][-1], end=self.home_pos[0], time_t=self.interpolate_time)
        interpolated_traj_translation[1] = self.get_interpolated_traj(start=sequence_traj_translation[1][-1], end=self.home_pos[1], time_t=self.interpolate_time)
        interpolated_traj_translation[2] = self.get_interpolated_traj(start=sequence_traj_translation[2][-1], end=self.home_pos[2], time_t=self.interpolate_time)
        interpolated_traj_rotation[0] = self.get_interpolated_traj(start=sequence_traj_rotation[0][-1], end=self.home_orn[0], time_t=self.interpolate_time)
        interpolated_traj_rotation[1] = self.get_interpolated_traj(start=sequence_traj_rotation[1][-1], end=self.home_orn[1], time_t=self.interpolate_time)
        interpolated_traj_rotation[2] = self.get_interpolated_traj(start=sequence_traj_rotation[2][-1], end=self.home_orn[2], time_t=self.interpolate_time)

        ''' Waiting time trajectory '''
        waiting_traj_translation = [None] * 3
        waiting_traj_rotation = [None] * 3

        new_wait_time = self.sequence_wait_time - self.interpolate_time

        waiting_traj_translation[0] = self.get_interpolated_traj(start=self.home_pos[0], end=self.home_pos[0], time_t=new_wait_time)
        waiting_traj_translation[1] = self.get_interpolated_traj(start=self.home_pos[1], end=self.home_pos[1], time_t=new_wait_time)
        waiting_traj_translation[2] = self.get_interpolated_traj(start=self.home_pos[2], end=self.home_pos[2], time_t=new_wait_time)
        waiting_traj_rotation[0] = self.get_interpolated_traj(start=self.home_orn[0], end=self.home_orn[0], time_t=new_wait_time)
        waiting_traj_rotation[1] = self.get_interpolated_traj(start=self.home_orn[1], end=self.home_orn[1], time_t=new_wait_time)
        waiting_traj_rotation[2] = self.get_interpolated_traj(start=self.home_orn[2], end=self.home_orn[2], time_t=new_wait_time)

        ''' Final combined trajectory '''
        if self.global_sequence_number == 0:
            f_translation = np.hstack([home_waiting_traj_translation, sequence_traj_translation,interpolated_traj_translation,waiting_traj_translation])
            f_rotation = np.hstack([home_waiting_traj_rotation, sequence_traj_rotation,interpolated_traj_rotation,waiting_traj_rotation])

        else:
            f_translation = np.hstack([sequence_traj_translation,interpolated_traj_translation,waiting_traj_translation])
            f_rotation = np.hstack([sequence_traj_rotation,interpolated_traj_rotation,waiting_traj_rotation])

        return f_translation, f_rotation


    def read_from_csv(self, file_name='', header=True):
        """
            Reads data from csv file.

            :param file_name: Name of csv file.
            :type file_name: str.
            :param header: Specify whether csv file have header or not.
            :type header: Bool.
            :return: Returns data from csv file.
            :rtype: list[str].
        """
        self.r_file = open(file_name)
        csv_reader = csv.reader(self.r_file)
        lines = []
        for line in csv_reader:
            lines.append(line)
        if header:
            lines = lines[1:] # cut out title line in csv file
        return lines

    
    def open_csv_for_write(self, file_name='', write_mode='w'):
        """
            Initialize writer and write header to csv file. 

            :file_name: Name of csv file. 
            :type file_name: str.
            :write_mode: File write mode.
            :type write_mode: char. 
            :return: None.
            :rtype: None.
        """
        print("Open csv for writing:", file_name)
        self.w_file = open(file_name, write_mode)
        self.data_writer = csv.writer(self.w_file)
        
        header = ['tx', 'ty', 'tz', 'rx', 'ry', 'rz']
        self.data_writer.writerow(header)


    def write_csv_row(self, row):
        """
            Writes to csv file. 

            :row: Row to write. 
            :type row: ndarray.
            :return: None.
            :rtype: None.
        """
        self.data_writer.writerow(row)


    def get_interpolated_traj(self, start, end, time_t = 5.0):
        """
            Generate interpolated trajectory.

            :param start: Starting point. 
            :type start: Float.
            :param end: Ending point. 
            :type end: Float.
            :param time_t: Sequence/wait time. 
            :type time_t: Float. 
            :return: Returns linear interpolated points.
            :rtype: list[]
        """
        yx = np.arange(0, 2)
        y = [start, end]
        f = interp1d(yx, y, kind='linear', axis=0)
        x = np.arange(0, 1, step=1/(time_t*self.frequency), dtype=float)
        return f(x)

'''
if __name__ == '__main__':
    GenerateSineTrajectoryClass()
'''