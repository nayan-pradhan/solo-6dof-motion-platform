'''
    Python script to generate circular trajectory
'''

import math
from webbrowser import get 
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d
import csv
from config import *

class GenerateCircularTrajectoryClass():

    def __init__(self, 
        frequency = 1000, # 1000 or 240 Hz
        home_position = [0.0,0.0,0.25], # [m, m, m]
        radius = 0.3, # m
        angle = 10, # deg
        no_of_rounds = 5, # int
        frequency_in_round = 2, # Hz
        starting_wait_time = 2, # s
        output_file_name = TRAJ_PLATFORM_FILE_NAME,
        input_file_name = '',
        do_translate = 1, 
        do_rotate = 1,
    ):
        self.output_file_name = GLOBAL_AUTOGENERATED_DIRECTORY + output_file_name 
        self.input_file_name = GLOBAL_INPUT_DIRECTORY + input_file_name

        input_circ_data = self.read_input()
        radius = (input_circ_data[0])/1000 # mm to m
        angle = math.radians(input_circ_data[1]) # deg to rad
        no_of_rounds = input_circ_data[2]
        frequency_in_round = input_circ_data[3]
        do_translate = input_circ_data[4]
        translate_dir = -1 if input_circ_data[5] == "cw" else 1
        do_rotate = input_circ_data[6]
        rotate_dir = 1 if input_circ_data[7] == "cw" else -1

        if not do_translate and radius:
            print("- Note: Translation is turned off but radius is given in input file. Radius will be ignored!")
        if not do_rotate and angle:
            print("- Note: Rotation is turned off but angle is given in input file. Angle will be ignored!")

        if not do_translate and not do_rotate:
            print("- Translation and Rotation turned off. Platform will not move!")

        env_frequency = frequency
        step_size = 1/env_frequency 
        self.env_frequency = env_frequency

        starting_wait_sequence = []
        for i in range(env_frequency * starting_wait_time):
            starting_wait_sequence.append((0,0,0.25,0,0,0))
        
        circle_sequence = []
        for i in range(no_of_rounds):
            t = 0
            while t*frequency_in_round<2*math.pi:
                circle_sequence.append((
                    do_translate*radius*math.cos(t*frequency_in_round)+home_position[0], 
                    translate_dir*do_translate*radius*math.sin(t*frequency_in_round)+home_position[1], 
                    home_position[2], 
                    do_rotate*angle*math.sin(t*frequency_in_round), 
                    rotate_dir*do_rotate*angle*math.cos(t*frequency_in_round), 
                    0
                    ))
                t+=step_size

        interpolation_traj = []
        interpolation_traj_tx = self.get_interpolated_traj(home_position[0], circle_sequence[0][0])
        interpolation_traj_ty = self.get_interpolated_traj(home_position[1], circle_sequence[0][1])
        interpolation_traj_tz = self.get_interpolated_traj(home_position[2], circle_sequence[0][2])
        interpolation_traj_rx = self.get_interpolated_traj(0, circle_sequence[0][3])
        interpolation_traj_ry = self.get_interpolated_traj(0, circle_sequence[0][4])
        interpolation_traj_rz = self.get_interpolated_traj(0, circle_sequence[0][5])
        interpolation_traj = np.hstack([interpolation_traj_tx, interpolation_traj_ty, interpolation_traj_tz, interpolation_traj_rx, interpolation_traj_ry, interpolation_traj_rz])
        
        r_interpolation_traj = []
        r_interpolation_traj_tx = self.get_interpolated_traj(circle_sequence[-1][0], home_position[0])
        r_interpolation_traj_ty = self.get_interpolated_traj(circle_sequence[-1][1], home_position[1])
        r_interpolation_traj_tz = self.get_interpolated_traj(circle_sequence[-1][2], home_position[2])
        r_interpolation_traj_rx = self.get_interpolated_traj(circle_sequence[-1][3], 0)
        r_interpolation_traj_ry = self.get_interpolated_traj(circle_sequence[-1][4], 0)
        r_interpolation_traj_rz = self.get_interpolated_traj(circle_sequence[-1][5], 0)
        r_interpolation_traj = np.hstack([r_interpolation_traj_tx, r_interpolation_traj_ty, r_interpolation_traj_tz, r_interpolation_traj_rx, r_interpolation_traj_ry, r_interpolation_traj_rz])
        
        final_traj = np.vstack([starting_wait_sequence, interpolation_traj, circle_sequence, r_interpolation_traj, starting_wait_sequence])

        self.write_output(final_traj)


    def get_interpolated_traj(self, start, end):
        """
            Generate interpolated trajectory.

            :param start: Starting point. 
            :type start: Float.
            :param end: Ending point. 
            :type end: Float.
            :return: Returns linear interpolated points.
            :rtype: list[]
        """
        yx = np.arange(0, 2)
        y = [start, end]
        f = interp1d(yx, y, kind='linear', axis=0)
        x = np.arange(0, 1, step=1/(1*self.env_frequency), dtype=float)
        return np.array([f(x)]).T


    def write_output(self, data):
        """
            Writes to csv file. 

            :data: Data to write in csv file. 
            :type data: list[float]
            :return: None.
            :rtype: None.
        """
        file = open(self.output_file_name, 'w')
        data_writer = csv.writer(file)
        data_writer.writerow(['tx', 'ty', 'tz', 'rx', 'ry', 'rz'])
        data_writer.writerows(data)
        file.close()


    def read_input(self, header=True):
        """
            Reads from csv file.

            :param header: True if csv file contains header, False if csv file does not contain header.
            :return: Returns all lines from csv file.
            :rtype: list[list[]].
        """
        file = open(self.input_file_name, 'r')
        csv_reader = csv.reader(file)
        if header:
            header_skipped = False 
        else:
            header_skipped = True
        lines = []
        for line in csv_reader:
            if not header_skipped:
                header_skipped=True 
                continue
            try:
                for elem_i, elem_val in enumerate(line):
                    if elem_i == 0 or elem_i == 1 or elem_i == 3: # radius, angle, frequency
                        lines.append(float(elem_val))
                    elif elem_i == 2: # no of periods
                        lines.append(int(elem_val))
                    elif elem_i == 4 or elem_i == 6: # 0 or 1
                        if int(elem_val) == 0 or int(elem_val) == 1: # translation, rotation
                            lines.append(int(elem_val))
                        else:
                            print("Translation/Rotation should be either 0 for False or 1 for True.\
                            \nCheck input file format and try again.")
                            exit(-1)
                    elif elem_i == 5 or elem_i == 7:
                        if str(elem_val) == "cw" or str(elem_val) == "ccw":
                            lines.append(str(elem_val))
                        else:
                            print("Translation/Rotation direction should be either cw or ccw.\
                            \nCheck input file format and try again.")
                            exit(-1)
                break # should only read first input line
            except Exception as e:
                print("Could not load input file:", self.input_file_name)
                print("Excpetion:", e)
                print("Exiting!")
                exit(-1)
        return lines
