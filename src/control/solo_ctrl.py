"""
    Python script for solo control. 
"""

from concurrent.futures import process
import math
import os
from time import process_time
from tkinter import *
import csv
from scipy.interpolate import interp1d
import numpy as np
import matplotlib.pyplot as plt
from config import *
import time

import libmaster_board_sdk_pywrap as mbs

class SoloControlClass():

    def __init__(self,
        name_interface = 'enp9s0f1',
        n_slaves = 6,
        csv_joint_positions_file_name = TRAJ_JOINTS_FILE_NAME,
        solo_output_file = SOLO_DATA_OUTPUT_FILE_NAME,
        phase_0_calibration = False,
        phase_1_calibration = False,
        phase_2_calibration = False,
    ):
        self.debug_mode = False
        self.counter = 0 
        self.current_time = 0
        self.frequency = 1000 # Control frequency
        self.dt = 1/self.frequency #  Time step
        self.n_slaves = n_slaves
        self.phase_0_calibration = phase_0_calibration
        self.phase_1_calibration = phase_1_calibration
        self.phase_2_calibration = phase_2_calibration
        self.name_interface = name_interface
        self.csv_joint_positions_file_name = GLOBAL_AUTOGENERATED_DIRECTORY+csv_joint_positions_file_name
        self.solo_output_file = GLOBAL_OUTPUT_DIRECTORY+solo_output_file
        self.unique_solo_output_file = GLOBAL_OUTPUT_DIRECTORY + HISTORY_DIR + SOLO_DATA_OUTPUT_FILE_UNIQUE

        self.init_starting_params()
        if self.phase_0_calibration:
            self.init_masterboard_params()
            print("PHASE 0 Calibration. Motors and masterboard initialized. Exiting... \n \
                    Run Phase 1 with -c flag. \n \
                    Run Phase 2 with -v flag. \n \
                    Run sequences using calibrated parameters with no flag.\n \
                    End of program.")
            exit(1)

        self.sequence_motion_trajectory = self.load_trajectory(self.csv_joint_positions_file_name)
        self.init_constant_positions_joint_angles() # loads smooth_home_pos and smooth_landing_pos

        if self.phase_1_calibration:
            self.phase_2_calibration = False 
        
        if not self.phase_1_calibration and not phase_2_calibration:
            print("Loading Phase 2 Calibration Indices.")
            self.load_calibrated_zero_angles = True 
        else:
            if self.phase_1_calibration:
                print("Running Phase 1 Calibration")
            else:
                print("Running Phase 2 Calibration")
            self.load_calibrated_zero_angles = False 

        self.init_masterboard_params()
        self.init_controller_params()

        if self.phase_1_calibration or self.phase_2_calibration:      
            self.init_calibration()

        self.main_loop()

        self.robot_if.Stop()  # Shut down the interface between the computer and the master board

        print('---')

        if self.robot_if.IsTimeout():
            print("Masterboard timeout detected.")
            print("Either the masterboard has been shut down or there has been a connection issue with the cable/wifi.")

    
    def main_loop(self):
        """
            Main execution block. Runs until robot is not timeout. Maintains frequency of 1000 Hz.  

            :return: None.
            :rtype: None.
        """
        self.prev_controller_time = time.time()
        self.prev_target = [0.0] * self.n_slaves * 2

        while ((not self.robot_if.IsTimeout()) or 1):  

            if self.program_complete:
                break

            if ((time.time() - self.last) > self.dt):
                self.last = time.time()

                if self.counter == 0:
                    self.data_file = open(self.solo_output_file, 'w')
                    self.data_file_c = open(self.unique_solo_output_file, 'w')
                    self.data_writer = csv.writer(self.data_file)
                    self.data_writer_c = csv.writer(self.data_file_c)
                    # header = ["counter[0]", "motor_pos[1-12]", "target_pos[13-24]", "current[25-36]", "imu[37-48]"] # update this later
                    header = [
                        "timestamp[0]",
                        "pos_bl_hip[1]", "pos_br_hip", "pos_bl_lower", "pos_bl_upper", "pos_br_lower", "pos_br_upper", "pos_fl_hip", "pos_fr_hip", "pos_fl_lower", "pos_fl_upper", "pos_fr_lower", "pos_fr_upper",
                        "target_pos_bl_hip[13]", "target_pos_br_hip", "target_pos_bl_lower", "target_pos_bl_upper", "target_pos_br_lower", "target_pos_br_upper", "target_pos_fl_hip", "target_pos_fr_hip", "target_pos_fl_lower", "target_pos_fl_upper", "target_pos_fr_lower", "target_pos_fr_upper",
                        "current_A_bl_hip[25]", "current_A_br_hip", "current_A_bl_lower", "current_A_bl_upper", "current_A_br_lower", "current_A_br_upper", "current_A_fl_hip", "current_A_fr_hip", "current_A_fl_lower", "current_A_fl_upper", "current_A_fr_lower", "current_A_fr_upper",
                        "imu_accelerometer_x[37]", "imu_accelerometer_y", "imu_accelerometer_z", "imu_gyroscope_x", "imu_gyroscope_y", "imu_gyroscope_z", "imu_attitude_x", "imu_attitude_y", "imu_attitude_z", "imu_linear_acceleration_x", "imu_linear_acceleration_y", "imu_linear_acceleration_z",
                        "adc[49]"
                    ]
                    self.data_writer.writerow(header)
                    self.data_writer_c.writerow(header)

                self.counter += 1

                if not self.phase_1_calibration and not self.phase_2_calibration:
                    self.sequence_counter += 1

                if self.phase_1_calibration or self.phase_2_calibration:
                    if not self.reset_calibration_complete:
                        self.reset_calibration_counter += 1

                self.current_time += self.dt
                self.robot_if.ParseSensorData()  # Read sensor data sent by the masterboard

                if (self.state == 0):  #  If the system is not ready
                    self.state = 1

                    # for all motors on a connected slave
                    for i in self.motors_spi_connected_indexes:  # Check if all motors are enabled and ready
                        if not (self.robot_if.GetMotor(i).IsEnabled() and self.robot_if.GetMotor(i).IsReady()):
                            self.state = 0
                        self.init_pos_motors[i] = self.robot_if.GetMotor(i).GetPosition()
                        self.current_time = 0


                else:  # If the system is ready
                    # for all motors on a connected slave
                    for i in self.motors_spi_connected_indexes:

                        if i % 2 == 0 and self.robot_if.GetDriver(i // 2).GetErrorCode() == 0xf:
                            #print("Transaction with SPI{} failed".format(i // 2))
                            continue #user should decide what to do in that case, here we ignore that motor
                        
                        self.global_motor_i = i
                        
                        if self.robot_if.GetMotor(i).IsEnabled():

                            if self.debug_mode:
                                self.debug_joint.get_joint()
                                self.debug_joint.set_joint_position()

                            elif self.phase_1_calibration:
                                self.fill_index_calibration()
                                if self.is_calibration_complted(self.index_calibration_array):
                                    self.completed_phase_1_exit = False 
                                    if not self.calibrated_offsets_saved:
                                        self.save_calibrated_offsets(phase=1, f_name=self.name_of_calibration_saved_csv)
                                    else:
                                        self.phase_1_calibration = False
                                        self.calibrated_zero_position = self.zero_position
                                    # if not self.phase_1_calibration:
                                else:
                                    self.run_calibration_synced()

                            elif not self.completed_phase_1_exit:
                                self.smooth_landing()

                            elif self.phase_2_calibration:
                                if self.calibrated_offsets == []:
                                    self.calibrated_offsets = self.load_offsets(f_name=self.name_of_calibration_saved_csv)
                                
                                self.fill_index_calibration()

                                if self.is_calibration_complted(self.phase_2_index_calibration_array):
                                    if not self.offsets_to_calibrated_zeros_saved:
                                        self.save_calibrated_offsets(phase=2, f_name=self.name_of_offset_calibrated_zeros_csv)
                                    self.phase_2_calibration = False 
                                    self.use_i = True
                                    self.calibrated_zero_position = self.calibration_target_position
                                    self.target_position = self.calibrated_zero_position
                                    
                                else:
                                    self.run_calibration_synced()

                            elif self.load_calibrated_zero_angles:
                                self.calibrated_zero_position = self.load_offsets(f_name=self.name_of_offset_calibrated_zeros_csv)
                                self.target_position = self.calibrated_zero_position
                                self.load_calibrated_zero_angles = False 
                                self.use_i = False 

                            elif not self.phase_1_calibration and \
                                    not self.phase_2_calibration and \
                                    not self.in_motion_trajectory_sequence and \
                                    not self.end_sequence:
                                self.go_to_home_position()


                            elif not self.trigger_is_triggered:
                                self.maintain_home_position()
                                self.read_trigger_signal()
                                

                            elif (self.in_home_position and self.start_sequence) or self.in_motion_trajectory_sequence:
                                if self.start_sequence:
                                    self.sequence_counter = 0
                                    print("Running sequence ... ")
                                    print('---')
                                    print("Sequence Start Time:", self.sequence_start_time)

                                self.start_sequence_motion_trajectory()

                                if self.sequence_counter % 1000 == 0:
                                    print('Sequence Run Time:', int(self.last - self.sequence_start_time),'s.', end='\r')


                            else: # ending
                                if self.sequence_counter == 0 and self.global_motor_i==2:
                                    print("Sequence completed!")
                                    print('---')
                                    print("Sequence End Time: ", self.sequence_end_time)
                                    print("Total Sequence Runtime:", self.sequence_end_time - self.sequence_start_time)
                                    print('---')
                                self.smooth_landing()

                    self.controller()

                    if not self.phase_0_calibration and not self.phase_1_calibration and not self.phase_2_calibration and self.trigger_is_triggered:                   
                        self.get_imu_data()
                        self.save_pos_in_arr()

                self.robot_if.SendCommand()  # Send the reference currents to the master board
    
    
    def maintain_home_position(self):
        """
            Maintains home position until trigger is pressed by setting target position as smooth home position.    

            :return: None.
            :rtype: None.
        """
        self.target_position = self.smooth_home_pos
        if ((self.counter % 3000) == 0 and self.global_motor_i == 4):
            print("Maintaining position.")
            print('---')
        
    
    def init_calibration(self):
        """
            Initialize calibration parameters.

            :return: None.
            :rtype: None.
        """
        self.zero_position = [0] * self.n_slaves * 2
        self.home_position = [0] * self.n_slaves * 2
        self.index_pos_array = [0] * self.n_slaves * 2
        self.index_calibration_array = [None] * self.n_slaves * 2
        self.phase_2_index_calibration_array = [None] * self.n_slaves * 2
        # self.calibration_joint_offset_step_value = 0.00000001
        self.calibration_joint_offset_step_value = 0.000001 # 0.000001 rad/ms = 0.00005729578 degrees/ms = 0.05729578 degrees/s in motor
        self.number_of_steps_for_calibration = 1000
        self.max_motor_angle_in_degrees = 25 # input in degrees (leg angle)
        self.min_motor_angle_in_degrees = -25 # input in degrees (leg angle)
        self.max_motor_angle = math.radians(self.max_motor_angle_in_degrees) * 9 # motor angle
        self.min_motor_angle = math.radians(self.min_motor_angle_in_degrees) * 9 # motor angle
        self.tolerance_for_startup_position_in_degrees = 10 # tolerance of leg at startup
        self.tolerance_for_startup_position = math.radians(self.tolerance_for_startup_position_in_degrees) * 9 # tolerance angle in radians at motor

        self.move_in_max_dir = True 
        self.calibration_target_position = self.zero_position
        self.calibration_joint_offset_array = [0] * self.n_slaves *2
        self.calibration_counter_i = 0
        self.calibration_counter_j = 0
        self.calibrated_offsets_saved = False 
        self.calibrated_hips_phase_1 = False 
        self.calibrated_lower_ls_phase_1 = False
        self.calibrated_upper_ls_phase_1 = False
        self.calibrated_hips_phase_2 = False 
        self.calibrated_hips_phase_2_prev = False 
        self.calibrated_lower_ls_phase_2 = False
        self.calibrated_lower_ls_phase_2_prev = False
        self.calibrated_upper_ls_phase_2 = False
        self.calibrated_offsets = []
        self.multiple_indices_found = [False] * self.n_slaves * 2
        self.target_hip_angles = None
        self.target_lower_ls_angles = None
        self.target_upper_ls_angles = None
        self.offsets_to_calibrated_zeros_saved = False

        self.reset_calibration_complete = True 
        self.reset_calibration_counter = 0
        self.smooth_reset_trajectory = [[None] * self.n_slaves * 2] 

    
    def load_trajectory(self, name_of_csv_file):
        """
            Loads PyBullet trajectory, does time scaling, does interpolation of trajectory to run in 1000 Hz, and outputs sequence with correct index mapping.

            :param name_of_csv_file: Name of csv file where trajectory is being loaded from.
            :type name_of_csv_file: str.
            :return: Time scaled, interpolated, and correct index trajectory for csv file.
            :rtype: list[float].
        """
        print('Loading trajectory for: '+name_of_csv_file+'...', end='')
        trajectory_from_csv = self.read_from_csv(name_of_csv_file, True, 2)
        mapped_trajectory = list([self.get_mapped_joints_from_pybullet_to_robot(trajector) for trajector in trajectory_from_csv])
        print(" Done!")
        return mapped_trajectory


    def read_from_csv(self, name_of_csv, header, num_headers=1):
        """
            Reads data from any csv file.

            :param name_of_csv: name of csv file.
            :type name_of_csv: str.
            :param header: Specify whether csv file have header or not.
            :type header: Bool.
            :return: Returns all data in the csv file.
            :rtype: list[list[float]].
        """
        t_num_headers = num_headers
        input_file = open(name_of_csv)
        csv_reader = csv.reader(input_file)
        data = []
        header_skipped = False
        for line in csv_reader:
            temp = []
            if header and not header_skipped:
                t_num_headers -= 1
                if t_num_headers == 0:
                    header_skipped = True

                if line[0] == 'pybullet':
                    print("\n==================================================================\n")
                    print("ERROR: SEQUENCE WAS GENERATED FOR PYBULLET ENV (240 HZ). EXITING!")
                    print("==================================================================\n")
                    exit(-1)

                continue
            for e in line:
                try:
                    temp.append(float(e))
                except:
                    temp.append(e)
            data.append(temp)
        return data


    def init_constant_positions_joint_angles(self):
        """
            Initializes constant positions joint angles.

            :return: None
            :rtype: None
        """
        # self.smooth_home_pos = self.get_mapped_joints_from_pybullet_to_robot([-0.037203307889674325,0.8290071456009634,-1.6202735010055305,0.03426181807382118,-0.8275963030031294,1.6176527246021368,0.037345308637274914,-0.829112352127045,1.6206753891770533,-0.03441811847655554,0.8276649056787524,-1.6178769925353353])
        self.smooth_home_pos = self.sequence_motion_trajectory[0]
        self.smooth_landing_pos = [-1.23277903, -2.27580261,  22.8462677,  -12.07741261, -23.30683899, 12.54417896, -1.92193758, -1.67543256, -23.13659668, 12.57938099, 23.45023537, -13.1005497]

    
    def get_mapped_joints_from_pybullet_to_robot(self, pybullet_trajectory):
        """
            Converts PyBullet joint/motor indices into robot joint/motor indices and returns updated trajectory.

            :param pybullet_trajectory: Trajectory from pybullet whose indices need to be updated.
            :type pybullet_trajectory: list[list[float]].
            :return: Trajectory with updated indices.
            :rtype: list[list[float]].
        """

        if len(pybullet_trajectory) != 12 and len(pybullet_trajectory) != 16:
            print("Number of joint positions != 12 or 16. Exiting!")
            exit(-1) 


        if len(pybullet_trajectory) == 16: # removing dummy joints if input
            dummy_joints = [3,7,11,15]
            updated_pybullet_trajectory = []
            for ti, tv in enumerate(pybullet_trajectory):
                if ti in dummy_joints:
                    continue
                else:
                    updated_pybullet_trajectory.append(tv)
        
            pybullet_trajectory = updated_pybullet_trajectory


        mapped_trajectory = [None] * self.n_slaves * 2
        # mapped_trajectory[robot_motor_index] = pybullet_trajectory[correpsonding_pybullet_joint_index]

        mapped_trajectory[self.motor_mapping["bl_hip"]] = - pybullet_trajectory[6] # bl_hip = hip_left_back 
        mapped_trajectory[self.motor_mapping["br_hip"]] = pybullet_trajectory[9] # br_hip = hip_right_back
        mapped_trajectory[self.motor_mapping["bl_lower"]] = pybullet_trajectory[8] # bl_lower = lower_leg_left_back
        mapped_trajectory[self.motor_mapping["bl_upper"]] = pybullet_trajectory[7] # bl_upper = upper_leg_left_back
        mapped_trajectory[self.motor_mapping["br_lower"]] = pybullet_trajectory[11] # br_lower = lower_leg_right_back
        mapped_trajectory[self.motor_mapping["br_upper"]] = pybullet_trajectory[10] # br_upper = upper_leg_right_back
        mapped_trajectory[self.motor_mapping["fl_hip"]] = pybullet_trajectory[0] # fl_hip = hip_left_front
        mapped_trajectory[self.motor_mapping["fr_hip"]] = - pybullet_trajectory[3] # fr_hip = hip_right_front
        mapped_trajectory[self.motor_mapping["fl_lower"]] = pybullet_trajectory[2] # fl_lower = lower_leg_left_front
        mapped_trajectory[self.motor_mapping["fl_upper"]] = pybullet_trajectory[1] # fl_upper = upper_leg_left_front
        mapped_trajectory[self.motor_mapping["fr_lower"]] = pybullet_trajectory[5] # fr_lower = lower_leg_right_front
        mapped_trajectory[self.motor_mapping["fr_upper"]] = pybullet_trajectory[4] # fr_upper = upper_leg_right_front
        
        mapped_trajectory = np.array(mapped_trajectory) * 9 # accounting for gearing

        return mapped_trajectory


    def init_starting_params(self):
        """
            Initialize starting parameters.

            :return: None.
            :rtype: None.
        """
        self.in_home_position = False 
        self.start_sequence = False 
        self.in_motion_trajectory_sequence = False 
        self.sequence_motion_trajectory = None 
        self.sequence_counter = 0 
        self.end_sequence = False 
        self.going_home = False 
        self.completed_phase_1_exit = True 
        self.name_of_calibration_saved_csv = GLOBAL_CALIBRATION_FILES_DIRECTORY+CALIBRATION_PHASE_1_FILE
        self.name_of_offset_calibrated_zeros_csv = GLOBAL_CALIBRATION_FILES_DIRECTORY+CALIBRATION_PHASE_2_FILE
        self.target_position = [0] * self.n_slaves * 2
        self.calibrated_zero_position = [0] * self.n_slaves * 2
        self.save_curr_pos = []
        self.save_curr_target = []
        self.save_time = [] 
        self.data = []

        self.smooth_landing_phase_1 = False 
        self.use_i = False
        self.finished_smooth_landing = False
        self.diff_threshold = 5.0
        self.motors_fighting = [False] * self.n_slaves * 2
        self.interploate_home_complete = False 
        self.interpolate_home_trajectory = [[None] * self.n_slaves * 2] 
        self.smooth_landing_trajectory_transition = [[None] * self.n_slaves * 2] 
        self.motor_pos = [0] * self.n_slaves * 2
        self.program_complete = False 
        self.trigger_is_triggered = False 
        self.imu_data = []

        self.adc_trigger_threshold = 0.50

        self.sequence_start_time = 0

        self.motor_mapping = {
            "bl_hip" : 0,
            "br_hip" : 1,
            "bl_lower" : 2,
            "bl_upper" : 3,
            "br_lower" : 4,
            "br_upper" : 5,
            "fl_hip" : 6,
            "fr_hip" : 7,
            "fl_lower" : 8,
            "fl_upper" : 9,
            "fr_lower" : 10,
            "fr_upper" : 11,
            0 : "bl_hip",
            1 : "br_hip",
            2 : "bl_lower",
            3 : "bl_upper",
            4 : "br_lower",
            5 : "br_upper",
            6 : "fl_hip",
            7 : "fr_hip",
            8 : "fl_lower",
            9 : "fl_upper",
            10 : "fr_lower",
            11 : "fr_upper"
        }


    def init_masterboard_params(self):
        """
            Initialize masterboard parameters.

            :return: None.
            :rtype: None.
        """
        self.state = 0 # State of the system (ready (1) or not (0))
        self.global_motor_i = 0
        os.nice(-20)  #  Set the process to highest priority (from -20 highest to +20 lowest)
        self.init_motor_drivers()
    

    def init_motor_drivers(self):
        """
            Initialize motor drivers.

            :return: None.
            :rtype: None.
        """
        self.init_pos_motors = [0.0 for i in range(self.n_slaves * 2)] # List that will store the initial position of motors
        
        self.motors_spi_connected_indexes = [] # indexes of the motors on each connected slaves
        self.motors_spi_connected_indexes_array = np.zeros(self.n_slaves*2) # 1 if motor at index is connected

        self.robot_if = mbs.MasterBoardInterface(self.name_interface)
        self.robot_if.Init()  # Initialization of the interface between the computer and the master board

        for i in range(self.n_slaves):  #  We enable each controler driver and its two associated motors
            self.robot_if.GetDriver(i).motor1.SetCurrentReference(0)
            self.robot_if.GetDriver(i).motor2.SetCurrentReference(0)
            self.robot_if.GetDriver(i).motor1.Enable()
            self.robot_if.GetDriver(i).motor2.Enable()
            self.robot_if.GetDriver(i).EnablePositionRolloverError()
            self.robot_if.GetDriver(i).SetTimeout(5)
            self.robot_if.GetDriver(i).Enable()

        self.last = time.time()

        while (not self.robot_if.IsTimeout() and not self.robot_if.IsAckMsgReceived()):
            if ((time.time() - self.last) > self.dt):
                self.last = time.time()
                self.robot_if.SendInit()

        if self.robot_if.IsTimeout():
            print("Timeout while waiting for ack.")
        else:
            # fill the connected motors indexes array
            for i in range(self.n_slaves):
                if self.robot_if.GetDriver(i).IsConnected():
                    # if slave i is connected then motors 2i and 2i+1 are potentially connected
                    self.motors_spi_connected_indexes.append(2 * i)
                    self.motors_spi_connected_indexes.append(2 * i + 1)

        for i in self.motors_spi_connected_indexes:
            self.motors_spi_connected_indexes_array[i] = 1


    def init_controller_params(self):
        """
            Initialize controller parameters.

            :return: None.
            :rtype: None.
        """
        # controller parameter
        # NOTE: Currently controller gain values are updated in the controller(self) method and are NOT following below gain values. 
        # ku = 3
        # tu = 1/self.frequency
        # self.seq_kp = ku*0.8
        # self.seq_kd = ku * tu
        # self.seq_kp = ku
        # self.seq_kd = 0.0
        self.seq_kp = 3.5
        self.seq_kd = 0.0375

        self.seq_ki = 0.0
        self.i_sat = 0.
        self.iq_sat = 12.0
        self.cur = np.zeros(self.n_slaves*2)
        self.controller_i = np.zeros(self.n_slaves*2)
        self.p_err = 0.0
        # print(self.seq_kp, self.seq_kd)


    def interpolate_smooth_trajectory(self, prev_sequence=None, next_sequence=None, step_size=1000):
        """
            Returns interpolated transition trajectory between two sequences/states.

            :param prev_sequence: Optional previous sequence.
            :type prev_sequence: list[list[float]] or None.
            :param next_sequence: Optional next sequence.
            :type next_sequence: list[list[float]] or None.
            :param step_size: Desired transition time between previous sequence and next_sequence in milli-seconds.
            :type step_size: Integer.
            :return: Interpolated transition trajectory.
            :rtype: list[list[float]].
        """
        yx = np.arange(0, 2) 

        if next_sequence is None:
            next_sequence = self.home_position_trajectory

        if prev_sequence is None:
            prev_sequence = [[self.robot_if.GetMotor(m).GetPosition() for m in range(self.n_slaves*2)]]

        y = [prev_sequence[-1], next_sequence[0]]
        f = interp1d(yx, y, kind='linear', axis=0)

        interpolate_x = np.arange(0, 1, step=1/step_size, dtype=float)
        transition_traj = f(interpolate_x)

        transition_traj[0] = prev_sequence[-1]

        return transition_traj


    def controller(self):
        """
            PD/PID Controller for Robot.

            :return: None.
            :rtype: None.
        """
        v_ref = 0 # desired velocity
        self.motor_pos = np.zeros(self.n_slaves*2)
        motor_vel = np.zeros(self.n_slaves*2)

        
        # Individual controller gains for different tasks
        if self.going_home:
            # self.iq_sat = 1.0
            self.kp = 4
            self.ki = 0.0
            self.kd = 0.03

        elif self.in_motion_trajectory_sequence:
            # self.iq_sat = 1.0
            self.kp = self.seq_kp
            self.ki = self.seq_ki
            self.kd = self.seq_kd

        elif self.phase_1_calibration or self.phase_2_calibration:
            # self.iq_sat = 1.0
            self.kp = 3
            self.ki = 0.0
            self.kd = 0.03

        else: 
            # self.iq_sat = 1.0
            self.kp = 4
            self.ki = 0.0
            self.kd = 0.03
        

        for i in range(self.n_slaves*2):
            self.motor_pos[i] = self.robot_if.GetMotor(i).GetPosition()
            motor_vel[i] = self.robot_if.GetMotor(i).GetVelocity()
        if self.phase_1_calibration or self.phase_2_calibration:
            self.p_err = (self.calibration_target_position - self.motor_pos) * self.motors_spi_connected_indexes_array # 0 for not connected indexes
        else:      
            self.target_position = np.array(self.target_position) + np.array(self.calibrated_zero_position)      
            self.p_err = (self.target_position - self.motor_pos) * self.motors_spi_connected_indexes_array # 0 for not connected indexes
        
        if self.phase_2_calibration or self.use_i:  # only use PID when calibrating
            for i in range(self.n_slaves*2):
                self.controller_i[i] += self.p_err[i]
                if self.controller_i[i] > self.i_sat:
                    self.controller_i[i] = self.i_sat
                elif self.controller_i[i] < - self.i_sat:
                    self.controller_i[i] = - self.i_sat  
        else: # else use PD controller 
            self.ki = 0

        v_err = (v_ref - motor_vel) * self.motors_spi_connected_indexes_array # 0 for not connected indexes
        
        # I part is 0 if not calibrating 
        self.cur = (self.kp * self.p_err) + (self.ki * self.controller_i) + (self.kd * v_err)

        for e in range(len(self.cur)):
            if self.cur[e] > self.iq_sat:
                self.cur[e] = self.iq_sat
            elif self.cur[e] < -self.iq_sat:
                self.cur[e] = -self.iq_sat
        
        for i in self.motors_spi_connected_indexes:
            if self.debug_mode:
                self.robot_if.GetMotor(i).SetCurrentReference(0.) # sets currents to 0 so nothing happens   
                # print(self.motor_pos)
            else:
                self.robot_if.GetMotor(i).SetCurrentReference(self.cur[i])

            # self.robot_if.GetMotor(i).SetCurrentReference(0.)     
            # self.robot_if.PrintIMU()
            
        # add anti gravity torque
        '''
            add here
        '''


    def go_to_home_position(self):
        """
            Sets target position to home posiiton by using interpolated trajectory to home position.

            :return: None.
            :rtype: None.
        """

        if not self.going_home:
            print("Going Home!")
            self.sequence_counter = 0
            self.interploate_home_complete = False 

 
        if not self.interploate_home_complete:
            if self.interpolate_home_trajectory[0][0] is None:
                self.interpolate_home_trajectory = self.interpolate_smooth_trajectory(next_sequence=[self.smooth_home_pos], step_size=TIME_INTERPOLATE_HOME)
                self.sequence_counter = 0 
                self.going_home = True 
                print("Starting interpolated trajectory!")
                print('---')

            elif self.sequence_counter == len(self.interpolate_home_trajectory)-1:
                self.interploate_home_complete = True 
                self.sequence_counter = 0
                self.interpolate_home_trajectory = [[None] * self.n_slaves * 2]
                print("Completed interpolated trajectory!")
            else:
                self.target_position = self.interpolate_home_trajectory[self.sequence_counter]
        else:
            self.going_home = True
         
            print("Completed homing!")
            print('---')
            self.in_home_position = True
            self.going_home = False

            if self.sequence_motion_trajectory is not None: 
                self.sequence_counter = 0
                self.start_sequence = True
                self.in_motion_trajectory_sequence = True 


    def smooth_landing(self):
        """
            Sets target position to smooth landing position by using interpolated trajectory to smooth landing position.

            :return: None.
            :rtype: None.
        """
        if self.finished_smooth_landing:
            if self.global_motor_i == 4:
                print("Program completed!")
                self.program_complete = True 
            return

        else:

            if not self.smooth_landing_phase_1:
                if self.sequence_counter == 0 and self.smooth_landing_trajectory_transition[0][0] is None:
                    print("Interpolating smooth landing trajectory!")
                    # print(self.counter)
                    # self.smooth_landing_trajectory_transition = self.interpolate_smooth_trajectory(next_sequence=[self.smooth_landing_trajectory[0]], step_size=1000)
                    self.smooth_landing_trajectory_transition = self.interpolate_smooth_trajectory(next_sequence=[self.smooth_landing_pos], step_size=TIME_INTERPOLATE_LANDING)
                    # self.target_position = np.array(self.smooth_landing_trajectory_transition[self.sequence_counter]) - np.array(self.calibrated_zero_position)   

                if (self.sequence_counter != len(self.smooth_landing_trajectory_transition)-1) or (self.sequence_counter==0):
                    # if self.sequence_counter == 0:
                    #     print(self.sequence_counter ,self.target_position)
                    self.target_position = np.array(self.smooth_landing_trajectory_transition[self.sequence_counter]) - np.array(self.calibrated_zero_position)   
                    # if self.sequence_counter == 1:
                    #     print(self.sequence_counter, self.target_position)
                    #     print('--')
                else:
                    self.sequence_counter = 0
                    # self.finished_smooth_landing = True
                    self.smooth_landing_trajectory_transition = [[None] * self.n_slaves * 2] 
                    # if self.completed_phase_1_exit:
                    #     self.completed_phase_1_exit = False 
                    self.smooth_landing_phase_1 = True 
                    print("Finished phase 1 smooth landing!")

            elif self.smooth_landing_phase_1:
                self.sequence_counter = 0
                self.finished_smooth_landing = True
                self.smooth_landing_trajectory_transition = [[None] * self.n_slaves * 2] 
                if self.completed_phase_1_exit:
                    self.completed_phase_1_exit = False 
                print("Finished smooth landing")
                print("---")


    def get_imu_data(self):
        """
            Gets data from imu and stores in imu_data list.  

            :return: None.
            :rtype: None.
        """
        self.imu_data = [] 
        for ii in range(3):
            self.imu_data.append(self.robot_if.imu_data_accelerometer(ii))
        for ii in range(3):
            self.imu_data.append(self.robot_if.imu_data_gyroscope(ii))
        for ii in range(3):
            self.imu_data.append(self.robot_if.imu_data_attitude(ii))
        for ii in range(3):
            self.imu_data.append(self.robot_if.imu_data_linear_acceleration(ii))


    def save_pos_in_arr(self):
        """
            Saves joint angles into csv file.

            :return: None.
            :rtype: None.
        """
        if not self.phase_0_calibration and not self.phase_1_calibration and not self.phase_2_calibration and self.trigger_is_triggered:
            line = [self.counter, *self.motor_pos, *self.target_position, *self.cur, *self.imu_data, self.robot_if.GetDriver(3).adc[0]]
            self.data_writer.writerow(line)
            self.data_writer_c.writerow(line)


    def start_sequence_motion_trajectory(self):
        """
            Sets target position to sequence motion trajectory.

            :return: None.
            :rtype: None.
        """
        self.start_sequence = False 
        self.in_home_position = False 
        self.in_motion_trajectory_sequence = True 
    
        if self.sequence_counter != len(self.sequence_motion_trajectory):
            self.target_position = np.array(self.sequence_motion_trajectory[self.sequence_counter])
        else:
            self.sequence_counter = 0 
            self.in_motion_trajectory_sequence = False  
            self.end_sequence = True 
            self.sequence_end_time = time.time()


    def check_motor_torques(self):
        """
            Checks motor torques and prints warning output if motors are fighting against each other.

            :return: Returns whether motors are fighting or not.
            :rtype: Bool.
        """
        offset_i_arr = []
        avg_offset_not_i_arr = []
        for motor_i_to_check in range(self.n_slaves*2):
            offset_i = abs(self.p_err[motor_i_to_check])
            offset_arr_not_i = list([abs(self.p_err[motor_j]) for motor_j in range(self.n_slaves*2) if motor_j!= motor_i_to_check])
            avg_offset_not_i = np.average(offset_arr_not_i)
            if offset_i > 2 * avg_offset_not_i and offset_i > self.diff_threshold:
                self.motors_fighting[motor_i_to_check] = True  
            else:
                self.motors_fighting[motor_i_to_check] = False
            offset_i_arr.append(offset_i)
            avg_offset_not_i_arr.append(avg_offset_not_i)

        # print debugger
        if any(self.motors_fighting):
            print("    Motor no.    Motor name.    Diff i.    Diff !i    Diff threshold")
            for motor_i in range(self.n_slaves*2):
                if self.motors_fighting[motor_i]: 
                    flag='  ->' 
                else: 
                    flag='    '
                print(flag, '   ', motor_i, '       ', self.motor_mapping[motor_i], '       %.3f'% offset_i_arr[motor_i], '       %.3f'% avg_offset_not_i_arr[motor_i], '         ', self.diff_threshold)
        are_motors_fighting = any(self.motors_fighting)
        self.motors_fighting = [False] * self.n_slaves * 12
        return are_motors_fighting # return true if any motors are fighting, else return false


    def run_calibration_synced(self):
        """
            Calls calibration process in sync for hip joints, lower leg joints, and upper leg joint. Used in Calibration Phase 1 and 2.

            :return: None.
            :rtype: None.
        """
        hips = [0, 1, 6, 7]
        lower_ls = [2, 4, 8, 10]
        upper_ls = [3, 5, 9, 11]

        if self.phase_1_calibration:
            if not self.calibrated_hips_phase_1 and not self.calibrated_lower_ls_phase_1 and not self.calibrated_upper_ls_phase_1:
                self.calibrate_together(hips)
            if self.calibrated_hips_phase_1 and not self.calibrated_lower_ls_phase_1 and not self.calibrated_upper_ls_phase_1:
                self.calibrate_together(lower_ls)
            if self.calibrated_hips_phase_1 and self.calibrated_lower_ls_phase_1 and not self.calibrated_upper_ls_phase_1: 
                self.calibrate_together(upper_ls)
            
            if self.calibrated_hips_phase_1 and self.calibrated_lower_ls_phase_1 and self.calibrated_upper_ls_phase_1:
                return
        
        elif self.phase_2_calibration:
                
            if not self.calibrated_hips_phase_2 and not self.calibrated_lower_ls_phase_2 and not self.calibrated_upper_ls_phase_2:             
                # print('Calibrating hips')
                self.calibrate_together(hips)

            if self.calibrated_hips_phase_2 and not self.calibrated_lower_ls_phase_2 and not self.calibrated_upper_ls_phase_2:
                if not self.calibrated_hips_phase_2_prev == self.calibrated_hips_phase_2:
                    self.calibration_target_position = self.zero_position       
                self.calibrate_together(lower_ls)

            if self.calibrated_hips_phase_2 and self.calibrated_lower_ls_phase_2 and not self.calibrated_upper_ls_phase_2: 
                if not self.calibrated_lower_ls_phase_2_prev == self.calibrated_lower_ls_phase_2:
                    self.calibration_target_position = self.zero_position   
                self.calibrate_together(upper_ls)
            self.calibrated_hips_phase_2_prev = self.calibrated_hips_phase_2
            self.calibrated_lower_ls_phase_2_prev = self.calibrated_lower_ls_phase_2
            
            if self.calibrated_hips_phase_2 and self.calibrated_lower_ls_phase_2 and self.calibrated_upper_ls_phase_2:
                self.set_calibrated_zero_pos()

                self.use_i = True
                self.calibrated_zero_position = self.calibration_target_position
                self.target_position = self.calibrated_zero_position
                
                self.phase_2_calibration = False
                if not self.offsets_to_calibrated_zeros_saved:
                    self.save_calibrated_offsets(phase=2, f_name=self.name_of_offset_calibrated_zeros_csv)

                return


    def set_calibrated_zero_pos(self):
        """
            Finds best motor indices.

            :return: None.
            :rtype: None.
        """
        sign_indices = np.array([1, -1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1])

        # all angles in radians and at the motor
        starting_position = 0 # position of motor at startup
        min_angle = starting_position + self.min_motor_angle * sign_indices
        max_angle = starting_position + self.max_motor_angle * sign_indices

        calibration_offset = self.calibrated_offsets
        index_found_at = self.phase_2_index_calibration_array
        tolerance = self.tolerance_for_startup_position

        if any(index_found_a == None for index_found_a in index_found_at):
            print('not all indices are found')
            exit()

        for i in range(self.n_slaves * 2):

            second_index_found = False # True if there are two indices while calibration
            final_index = None
            
            # check if there's a second index in this calibration sequence
            # positive direction
            if index_found_at[i] < max_angle[i] - math.pi * 2 and sign_indices[i] > 0:
                second_index_found = True
            # negative direction
            elif index_found_at[i] > max_angle[i] + math.pi * 2 and sign_indices[i] < 0:
                second_index_found = True

            if not second_index_found:
                final_index = 1
            # check if the calibration offset of phase one is possible with respect to the angle restrictions
            # positive direction
            elif index_found_at[i] - calibration_offset[i] < min_angle[i] and index_found_at[i] + math.pi * 2 - calibration_offset[i] < max_angle[i] and sign_indices[i] > 0:
                final_index = 2
            # negative direction
            elif index_found_at[i] - calibration_offset[i] > min_angle[i] and index_found_at[i] - math.pi * 2 - calibration_offset[i] > max_angle[i] and sign_indices[i] < 0:
                final_index = 2
            else:
                final_index = 1

            # calculate position to calibrated zero position
            if final_index == 1:
                calibrated_zero_position = index_found_at[i] - calibration_offset[i]
                # check if calculated position is in tolerance zone
                while calibrated_zero_position > tolerance:
                    calibrated_zero_position -= math.pi * 2
                while calibrated_zero_position < -tolerance:
                    calibrated_zero_position += math.pi * 2
            else:
                    calibrated_zero_position = index_found_at[i] + math.pi * 2 * sign_indices[i] - calibration_offset[i]

            self.calibration_target_position[i] = calibrated_zero_position

            print('motor index', i, 'zero_calc:', calibrated_zero_position, 'index found at:', index_found_at[i], 'calibration_offset', calibration_offset[i])


    def calibrate_together(self, motor_arr):
        """
            Runs actual calibration process where target position is updated with small steps until either maximum or minimum angle threshold is reached, or until all motor indices are found. 

            :param motor_arr: A list of motor ids that need to be calibrated together (hips, upper legs, lower legs).
            :type motor_arr: list[int].
            :return: None.
            :rtype: None.
        """
        if self.counter % 1 == 0 and ((self.global_motor_i+1) % 12) == 0: 

            if not self.reset_calibration_complete:
                self.reset_calibration(motor_arr)
                return 
            else:
                self.reset_calibration_counter = -1
            # print(list([self.robot_if.GetMotor(actual_motor_i).GetPosition() / 9 for actual_motor_i in range(self.n_slaves*2)]))

            motor_angles = [] # stores current motor angles 
            for motor_angles_index, actual_motor_i in enumerate(motor_arr):
                # print(actual_motor_i)
                m_angle = self.robot_if.GetMotor(actual_motor_i).GetPosition()  
                motor_angles.append(m_angle) 

            if self.check_is_motor_arr_complete(motor_arr):
                print("Motor indices array is complete")
                # self.reset_calibration(motor_arr)
                self.reset_calibration_complete = False 

            # print('motor_angles',motor_angles)
            # go 1 direction
            if self.move_in_max_dir:  
                # print("Move in forward direction")
                if any(motor_angles[mi] < self.max_motor_angle for mi in range(len(motor_angles)) if mi%2 == 0):
                    # move in forward direction 
                    for motor_angles_index, actual_motor_i in enumerate(motor_arr):
                        if motor_angles_index % 2 == 0:
                            self.calibration_joint_offset_array[actual_motor_i] += self.calibration_joint_offset_step_value
                        elif motor_angles_index % 2 != 0:
                            self.calibration_joint_offset_array[actual_motor_i] -= self.calibration_joint_offset_step_value
                    # print(self.counter, self.global_motor_i, self.calibration_target_position[0])
                    self.calibration_target_position = np.asarray(self.calibration_target_position) + np.asarray(self.calibration_joint_offset_array)
                else:
                # if all(motor_angles[mi] > self.max_motor_angle for mi in range(len(motor_angles)) if mi%2 == 0):
                    # print('\n')
                    print('All motor anges > max')
                    # print('\n')
                    self.move_in_max_dir = False 
                    # if self.phase_1_calibration:
                    #     self.calibration_target_position = [0]*self.n_slaves*2 
                    self.calibration_joint_offset_array = [0]*self.n_slaves*2 

            # go other direction 
            elif not self.move_in_max_dir:
                # print("Move in opposite direction")
                if any(motor_angles[mi] > self.min_motor_angle for mi in range(len(motor_angles)) if mi%2 == 0):
                    # move in backwards direction 
                    for motor_angles_index, actual_motor_i in enumerate(motor_arr):
                        if motor_angles_index % 2 == 0:
                            self.calibration_joint_offset_array[actual_motor_i] -= self.calibration_joint_offset_step_value
                        elif motor_angles_index % 2 != 0:
                            self.calibration_joint_offset_array[actual_motor_i] += self.calibration_joint_offset_step_value

                    self.calibration_target_position = np.asarray(self.calibration_target_position) + np.asarray(self.calibration_joint_offset_array)
                else:
                # if all(motor_angles[mi] < self.min_motor_angle for mi in range(len(motor_angles)) if mi%2 == 0):
                    # print('\n')
                    print('All motor anges < min')
                    # print('\n')
                    # self.reset_calibration(motor_arr)
                    self.reset_calibration_complete = False 


    def check_is_motor_arr_complete(self, motor_arr):
        """
            Checks if all motor indices are found for motors with id specified in motor_arr.

            :param motor_arr: A list of motor ids to check if all motor indices are found.
            :type motor_arr: list[int].
            :return: Returns True if all motor indices are found and False if all motor indices are not found.
            :rtype: Bool.
        """
        if self.phase_1_calibration:
            return not any(list([self.index_calibration_array[m] is None for m in motor_arr])) 
        elif self.phase_2_calibration:
            return not any(list([self.phase_2_index_calibration_array[m] is None for m in motor_arr])) 


    def reset_calibration(self, motor_arr):
        """
            Resets temporary calibration arrays and parameters after one calibration step is complete. Interpolates smooth trajectory to go back to calibration position after each calibration step is complete.

            :param motor_arr: A list of motor ids which will be moved back to calibration position after interpolation.
            :type motor_arr: list[int].
            :return: None.
            :rtype: None.
        """
        if self.reset_calibration_counter == 0 and self.smooth_reset_trajectory[0][0] is None:
            print("Interpolated smooth reset calibration.")
            self.smooth_reset_trajectory = self.interpolate_smooth_trajectory(next_sequence=[self.zero_position], step_size=2000)

        if (self.reset_calibration_counter != len(self.smooth_reset_trajectory)-1) or (self.reset_calibration_counter == 0):
            self.calibration_target_position = self.smooth_reset_trajectory[self.reset_calibration_counter]
        else:
            self.reset_calibration_complete = True 
            self.smooth_reset_trajectory = [[None] * self.n_slaves * 2] 

        if self.reset_calibration_complete:
            if self.phase_1_calibration:
                if motor_arr[0] == 0: self.calibrated_hips_phase_1 = True 
                elif motor_arr[0] == 2: self.calibrated_lower_ls_phase_1 = True 
                elif motor_arr[0] == 3: self.calibrated_upper_ls_phase_1 = True 
                self.print_calibration_status(self.calibrated_hips_phase_1, self.calibrated_lower_ls_phase_1, self.calibrated_upper_ls_phase_1)
            elif self.phase_2_calibration:
                if motor_arr[0] == 0: self.calibrated_hips_phase_2 = True 
                elif motor_arr[0] == 2: self.calibrated_lower_ls_phase_2 = True 
                elif motor_arr[0] == 3: self.calibrated_upper_ls_phase_2 = True 
                self.print_calibration_status(self.calibrated_hips_phase_2, self.calibrated_lower_ls_phase_2, self.calibrated_upper_ls_phase_2)
            
            self.move_in_max_dir = True
            self.calibration_counter_i += 1
            self.calibration_counter_j = 0
            self.calibration_joint_offset_array = [0] * self.n_slaves *2

            self.reset_calibration_counter = -1

            print('---')

        
    def print_calibration_status(self, hips, upper, lower):
        """
            Prints calibration status for hips, upper, and lower legs. 

            :param hips: True if hips are calibrated, False if not. 
            :type hips: Bool.
            :param upper: True if upper legs are calibrated, False if not. 
            :type upper: Bool.
            :param lower: True if lower legs are calibrated, False if not. 
            :type lower: Bool.
            :return: None.
            :rtype: None.
        """
        print("Hips Calibrated       :", hips)
        print("Upper Legs Calibrated :", upper)
        print("Lower Legs Calibrated :", lower)


    def fill_index_calibration(self):
        """
            Checks if motor index has been detected and fills index_calibration_array if index is found.

            :return: None.
            :rtype: None.
        """
        for i in range(self.n_slaves*2):
            if self.robot_if.GetMotor(i).HasIndexBeenDetected():
                if self.phase_1_calibration:
                    if self.index_calibration_array[i] is None: # if array not filled 
                        self.index_calibration_array[i] = self.robot_if.GetMotor(i).GetPosition() # in rad 
                        print("Phase 1 Calibration Array:",self.index_calibration_array)
                elif self.phase_2_calibration:
                    if self.phase_2_index_calibration_array[i] is None: # if array not filled 
                        self.phase_2_index_calibration_array[i] = self.robot_if.GetMotor(i).GetPosition() # in rad 
                        print("Phase 2 Calibration Array:",self.phase_2_index_calibration_array)


    def is_calibration_complted(self, cali_array):
        """
            Checks if calibration array is filled.

            :param cali_array: Calibration array is filled with motor position (float) if found index, else is None 
            :type cali_array: list[None, float].
            :return: Returns True if all motor indices are found and False if all motor indices are not found.
            :rtype: Bool.
        """
        for i in range(self.n_slaves*2):
            if cali_array[i] is None:
                return False 
        return not self.phase_2_calibration

    
    def read_trigger_signal(self): 
        """
            Reads ADC trigger from masterboard and sets trigger_is_triggered if trigger is detected.  

            :return: None.
            :rtype: None.
        """
        if ((self.counter % 3000) == 0 and self.global_motor_i == 4):            
            print("Waiting for ADC trigger.")
            print("---")

        if (self.robot_if.GetDriver(3).adc[0]) > self.adc_trigger_threshold:
            print("ADC Triggered! Starting Sequence Movement...")
            self.trigger_is_triggered = True
            self.sequence_start_time = time.time()
            print("---")


    def load_offsets(self, f_name):
        """
            Loads calibration offsets from given file.

            :param f_name: Name of file.
            :type f_name: str.
            :return: Returns calibraiton offset array.
            :rtype: list[float].
        """
        row = []
        try:
            f = open(f_name, 'r')
            reader = csv.reader(f)
            for line in reader:
                row.append(line)
            row = list([float(co) for co in row[-1]])
            print("CSV:", f_name, "loaded successfully!")
            print('---')
            if f_name == self.name_of_calibration_saved_csv:
                print("Calibration offsets from Phase 1:", row)
            elif f_name == self.name_of_offset_calibrated_zeros_csv:
                print("Calibration zero offset from Phase 2:", row)
            else:
                print("Loaded values:", row)
        except:
            print("CSV:", f_name, "not found! Exiting.")
            exit(1)
        print('---')
        return row 


    def save_calibrated_offsets(self, phase, f_name):
        """
            Saves calibration offsets into given file.

            :param phase: Calibration phase 1 or 2.
            :type phase: int.
            :param f_name: Name of file.
            :type f_name: str.
            :return: None.
            :rtype: None.
        """
        f = open(f_name, 'w')
        writer = csv.writer(f)
        if phase == 1:
            row = self.index_calibration_array
            writer.writerow(row)
            f.close()
            self.calibrated_offsets_saved = True
        elif phase == 2:
            row = self.calibrated_zero_position
            writer.writerow(row)
            f.close() 
            self.offsets_to_calibrated_zeros_saved = True
        print("Phase", phase, "~ Calibration saved as:", f_name, "!")


    def print_debugger(self):
        """
            Prints debugger similar to Masterboard code. 

            :return: None.
            :rtype: None.
        """
        if ((self.counter % 100) == 0):  # Display state of the system once every 100 iterations of the main loop
            # print(chr(27) + "[2J")
            # To read IMU data in Python use robot_if.imu_data_accelerometer(i), robot_if.imu_data_gyroscope(i)
            # or robot_if.imu_data_attitude(i) with i = 0, 1 or 2
            self.robot_if.PrintIMU()
            self.robot_if.PrintADC()
            self.robot_if.PrintMotors()
            self.robot_if.PrintMotorDrivers()
            self.robot_if.PrintStats()
            print(self.cur)
            if self.debug_mode:
                print('--- DEBUG ---')
                print('Active Joint: ', self.debug_joint.joint, ' position offset: ', self.debug_joint.joint_position[self.debug_joint.joint])
            #sys.stdout.flush()  # for Python 2, use print( .... , flush=True) for Python 3
            print(flush=True)
            print(self.current_time)

