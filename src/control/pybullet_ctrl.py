import time
import pybullet as p
import pybullet_data
import numpy as np
import math
import csv
from matplotlib import pyplot as plt
from config import *

class PybulletControlClass():

    def __init__(self, render_gui = True,
                        kp = 10,
                        kd = 0, 
                        torque_saturation = 2):
        
        self.render_gui = render_gui
        self.kp = kp
        self.kd = kp/100
        self.torque_saturation = torque_saturation

        self.torque_constant = 0.18 # torque constant from documentation (Nm/A)

        self.pybullet_frequency = 240.0
        self.robot_id = None
        self.platform_id = None
        self.dummy_joints = []

        self.joint_targets = None
        self.curr_platform_pos = []
        self.curr_platform_orn = []
        self.curr_joint_pos = []
        self.motor_currents = []

        self.joint_positions = self.read_from_csv(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME, True, 2)  
        self.platform_positions = self.read_from_csv(GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_PLATFORM_FILE_NAME, True)  

        self.setup_pybullet_model()  
        self.start_motion()

        self.store_data()

        


    def setup_pybullet_model(self):
        if self.render_gui:
            p.connect(p.GUI)
        else:
            p.connect(p.DIRECT)
    
        p.setGravity(0,0,-9.81)
        p.resetDebugVisualizerCamera(cameraDistance=1, cameraYaw=50, cameraPitch=-35, cameraTargetPosition=[0,0,0])
        p.configureDebugVisualizer(p.COV_ENABLE_GUI,0) # faster visualization by disabling OpenGL3
        
        # load plane URDF model
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        p.loadURDF("plane.urdf")

        p.setTimeStep(1/self.pybullet_frequency)

        # load robot URDF model
        URDF_home_position = [0,0,0]
        URDF_home_orientation = p.getQuaternionFromEuler([0,0,0])
        self.robot_id = p.loadURDF("../resources/URDF/URDF_motion_simulator_simplified_dummy/urdf/URDF_motion_simulator_simplified_dummy.urdf",
                            URDF_home_position, 
                            URDF_home_orientation, 
                            useFixedBase = 1)
        p.changeVisualShape(objectUniqueId=self.robot_id, linkIndex=2, rgbaColor=[0.48235294, 0.19607843, 0.58039216, 0.8])
        p.changeVisualShape(objectUniqueId=self.robot_id, linkIndex=6, rgbaColor=[0.76078431, 0.64705882, 0.81176471, 0.8])
        p.changeVisualShape(objectUniqueId=self.robot_id, linkIndex=10, rgbaColor=[0.65098039, 0.85882353, 0.62745098, 0.8])
        p.changeVisualShape(objectUniqueId=self.robot_id, linkIndex=14,rgbaColor=[0.        , 0.53333333, 0.21568627, 0.8])

        # initialize motors
        p.setJointMotorControlArray(bodyUniqueId=self.robot_id, jointIndices=list(range(16)), controlMode=p.VELOCITY_CONTROL, forces=np.zeros(16))

        # load platform URDF model
        URDF_home_position = self.platform_positions[0][:3]
        URDF_home_orientation = p.getQuaternionFromEuler(self.platform_positions[0][3:])
        self.platform_id = p.loadURDF("../resources/URDF/URDF_sensor_platform_simplified/urdf/URDF_sensor_platform_simplified.urdf",
                            URDF_home_position, 
                            URDF_home_orientation, 
                            useFixedBase = 0)

        # disable collision for dummy joints
        self.dummy_joints = [3, 7, 11, 15]
        for i in self.dummy_joints:
            p.setCollisionFilterPair(self.robot_id, self.platform_id, i, -1, False) # disable collision

        # Set contraints between legs and platform
        joint_pos_leg = np.array([-1.1, 0, -93.07])/1000 # relative Position of new Joint to COM of link
        joint_pos_platform = np.array([181.65, 118.89, 6.73])/1000   # relative Position of ball joint to origin
        offset_com_platform = np.array([-6.23, 1.26, -4.63])/1000 # offset center of mass to origin of the platform
        joint_indices = [2, 6, 10, 14] # Indices of the lower legs (FL, FR, HL, HR)
        
        
        for i in joint_indices:
            p.setCollisionFilterPair(self.robot_id, self.platform_id, i, -1, False) # disable collision
            newjoint_pos_leg = joint_pos_leg # Position of new joint

            if i == joint_indices[0]: # front left
                newjoint_pos_platform = joint_pos_platform + offset_com_platform
            elif i == joint_indices[1]: # front right
                newjoint_pos_platform = joint_pos_platform * np.array([1, -1, 1]) + offset_com_platform
            elif i == joint_indices[2]: # back left
                newjoint_pos_platform = joint_pos_platform * np.array([-1, 1, 1]) + offset_com_platform
            elif i == joint_indices[3]: # back right
                newjoint_pos_platform = joint_pos_platform * np.array([-1, -1, 1]) + offset_com_platform

            cid = p.createConstraint(
            self.robot_id,                # Parent body unique ID
            i,                      # Parent link index
            self.platform_id,             # Child body unique ID
            -1,                     # Child link index (-1 for base)
            p.JOINT_POINT2POINT,    # Joint type
            [0,0,0],                # Joint axis in child link frame
            newjoint_pos_leg,         # Position of the joint frame relative to parent center of mass frame.
            newjoint_pos_platform,    # Position of the joint frame relative to a given child center of mass frame 
            )

            p.changeConstraint(cid, maxForce = 20.)     # Set maxForce of constraint

    def start_motion(self):
        counter = 0
        last_time = 0
        while counter < len(self.joint_positions):
            if time.process_time() - last_time > 1./self.pybullet_frequency:
                self.joint_targets = self.joint_positions[counter]
                # save current platform position
                self.curr_platform_pos.append(p.getBasePositionAndOrientation(self.platform_id)[0])
                self.curr_platform_orn.append(p.getEulerFromQuaternion(p.getBasePositionAndOrientation(self.platform_id)[1]))
                temp = []
                for i in range(16):
                    temp.append(p.getJointState(self.robot_id, i)[0])
                self.curr_joint_pos.append(temp)

                last_time = time.process_time()
                
                p.stepSimulation() 
                self.controller()
                counter += 1

        p.disconnect()


    def controller(self):
        velocity_target = 0
        torque = []
        current = []
        for i in range(len(self.joint_targets)):
            # get joints positions
            joint_state = p.getJointState(self.robot_id, i)
            joint_pos = joint_state[0]
            joint_vel = joint_state[1]

            # calculate error
            pos_err = self.joint_targets[i] - joint_pos
            vel_err = velocity_target - joint_vel

            # calculate torque
            torque.append(pos_err * self.kp + vel_err * self.kd)
            # calculate current from torque
            current.append(torque[-1] / self.torque_constant)
            # saturation
            if torque[-1] > self.torque_saturation:
                torque[-1] = self.torque_saturation
            elif torque[-1] < -self.torque_saturation:
                torque[-1] = -self.torque_saturation

        self.motor_currents.append(current)
        
        p.setJointMotorControlArray(bodyUniqueId=self.robot_id, 
                                    jointIndices=list(range(len(self.joint_targets))), 
                                    controlMode=p.TORQUE_CONTROL, 
                                    forces=torque)

        


    def read_from_csv(self, path, header = False, num_headers=1):
        t_num_headers = num_headers
        f = open(path)
        data = []
        for line in csv.reader(f):
            if header:
                if path == GLOBAL_AUTOGENERATED_DIRECTORY + TRAJ_JOINTS_FILE_NAME:
                    if line[0] == 'solo':
                        print("\n==============================================================")
                        print("ERROR: SEQUENCE WAS GENERATED FOR SOLO ENV (1000 HZ). EXITING!")
                        print("==============================================================\n")
                        exit(-1)
                t_num_headers -= 1
                if t_num_headers == 0:      
                    header = False
            else:
                temp = []
                for e in line:
                    try:
                        temp.append(float(e))
                    except:
                        temp.append(e)
                data.append(temp)
        f.close()
        return data

    def store_data(self):
        f = open(GLOBAL_OUTPUT_DIRECTORY + PYBULLET_DATA_OUTPUT_FILE_NAME, 'w')
        f_c = open(GLOBAL_OUTPUT_DIRECTORY + HISTORY_DIR + PYBULLET_DATA_OUTPUT_FILE_UNIQUE, 'w')
        writer = csv.writer(f)
        writer_c = csv.writer(f_c)
        header = ['counter[0]', 
                    'current_joint_pos[1-16]', 
                    'target_joint_pos[17-32]', 
                    'motor_current[33-48]',
                    'current_platform_pos[49-51]', 
                    'target_platform_pos[52-54]',
                    'current_platform_orn[55-57]', 
                    'target_platform_orn[58-60]']
        writer.writerow(header)
        writer_c.writerow(header)

        self.curr_joint_pos = np.array(self.curr_joint_pos)
        self.joint_positions = np.array(self.joint_positions)
        self.motor_currents = np.array(self.motor_currents)
        self.platform_positions = np.array(self.platform_positions)
        self.curr_platform_pos = np.array(self.curr_platform_pos)
        self.curr_platform_orn = np.array(self.curr_platform_orn)

        for i in range(len(self.joint_positions)):
            row = []
            row.append(i)
            for e in self.curr_joint_pos[i, :]:
                row.append(e)
            for e in self.joint_positions[i, :]:
                row.append(e)
            for e in self.motor_currents[i, :]:
                row.append(e)
            for e in self.curr_platform_pos[i, :]:
                row.append(e)
            for e in self.platform_positions[i, :3]:
                row.append(e)
            for e in self.curr_platform_orn[i, :]:
                row.append(e)
            for e in self.platform_positions[i, 3:]:
                row.append(e)
            writer.writerow(row)
            writer_c.writerow(row)

        f.close()
        f_c.close()


if __name__ == '__main__':
    PybulletControlClass(render_gui = True)